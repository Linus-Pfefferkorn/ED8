

{Preregister functions}

PreregisterFunction([NAC_Conveyor_Curved_Right_3D], 1, 1);
PreregisterFunction([NAC_Curved_Right_Old], 1, 1);


{Atom: Right Curved Non Accumulating Conveyor}

sets;
BaseClass;
CreateAtom(a, s, [], 1, false);
Set(OnInit, [do( {**Load Functions Atom if required**} if(not(AtomExists(AtomByName([General Conveyor Functions]),Library)), int035([General Conveyor Functions], pDir([Atoms\General Conveyor Functions.atm]))   )) ]);
int023([Right Curved Non Accumulating Conveyor], 11249415, 1266);
DefineFunction([NAC_Conveyor_Curved_Right_3D], [Conveyors], 1, 1, [If(  att([Radius], p(1)) > ySize(p(1)),  Do(    var([atmC], vbAtom),        atmC:= p(1),          var([valNrOfParts], vbValue),    var([valAngle], vbValue, att([angle], atmC)),    var([valElevation], vbValue, att([Elevation], atmC)),    var([valRadius], vbValue, att([Radius], atmC)),    var([valRotation], vbValue),    var([val3DIconCode], vbValue, att([3DIconCode], atmC)),        var([valNrOfLegs], vbValue,Label([NumberOfSupports], atmC)),    var([valLegExtend], vbValue, att([LegExtend], atmC)),        var([valAngleStep], vbValue, att([AngleStep], atmC)),      var([valSensorAngle], vbValue),        var([valLegSpacing], vbValue, att([legspacing], atmC)),        var([valEndAngle], vbValue, att([EndAngle], atmC)),    var([valStartAngle], vbValue, att([StartAngle], atmC)),    var([valHeight], vbValue, zSize(atmC)),    var([valCurSize], vbValue, 0),    var([valLegSize], vbValue, 0),    var([valLength], vbValue, att([Length], atmC)),      var([valSegment], vbValue),      If(      valRadius>2,      valNrOfParts:=Round(2*pi*(valRadius-1+0.5*ySize(atmC)) * abs((valAngle)/360)/0.131+1,0),      valNrOfParts:=Round(2*pi*(valRadius +0.5*ySize(atmC))* (abs(valAngle)/360)/0.261+1,0)    ),          Repeat(      valNrOfParts,      Do(        PushCoords,        RotateCoords((valAngle/valNrOfParts)*(Count) - 90 + valStartAngle, 0, 0, 1, 0,0,0),          DrawModel3DMesh(          model3d(1,atmC),          Case(            InList(              val3DIconCode,              1,              2,              3            ),            Do(              SetMaterialColor(Color(atmC), DIFFUSE_AND_AMBIENT_COLOR),              SetMaterialTwoSided(True),              SetMaterialOverride(True),                         if(valElevation>=0,3,7) {Mesh with selected color}            ),            if(valElevation>=0,3,7), {Mesh conveyor belt}            Do(              SetmaterialShininess(0.8),              SetMaterialOverride(True),              5  {Mesh rollers}            )          ),          valRadius-ySize(atmC),           0,          (valElevation/valNrOfParts) * Count + zSize(atmC),           ySize(AtmC),          1,          If(            valElevation<>0,            abs((valElevation/valNrOfParts)/0.04)*-1,            -(0.001)          )        ),        PopCoords      )    ),        Repeat(      valNrOfParts,      Do(        PushCoords,        RotateCoords((valAngle/valNrOfParts)*Count - 90 + valStartAngle, 0, 0, 1, 0,0,0),        SetMaterialColor(Color(atmC), DIFFUSE_AND_AMBIENT_COLOR),        SetMaterialTwoSided(True),        SetMaterialOverride(True),        DrawModel3DMesh(          model3d(1,atmC),          if(valElevation>0,4,6), {Mesh borders}          valRadius-ySize(atmC),           0,          (valElevation/valNrOfParts)*Count+zSize(atmC)+0.001,           1,           1,          If(            valElevation<>0,            abs((valElevation/valNrOfParts)/0.04)* -1,            -(0.001)          )        ),        DrawModel3DMesh(          model3d(1,atmC),          if(valElevation>0,1,8), {Mesh borders}          valRadius,           0,          (valElevation/valNrOfParts)*Count+zSize(atmC)+0.001,           1,           1,          If(            valElevation<>0,            abs((valElevation/valNrOfParts)/0.04)* -1,            -(0.001)          )        ),              PopCoords      )          {The small additions (0.001) are to prevent interferention when polygons are placed at the same height!}    ),        {Drawing the legs of the conveyors}    if(      valLegSpacing > 0,      Do(      Repeat(        valNrOfLegs,        Do(          PushCoords,          RotateCoords(valEndAngle - 90 - (valAngleStep * (count-1)), 0, 0, 1),          SetMaterialColor(Color(atmC), DIFFUSE_AND_AMBIENT_COLOR),          SetMaterialTwoSided(True),          SetMaterialOverride(True),          DrawModel3DMesh(            Model3D(1,atmC),            2,            valRadius - ySize(atmC),            0,            0,            1,            1,            if(              valElevation>0,                            valElevation + valHeight - (abs(valElevation) / valAngle)*valAngleStep * (Count-1),              if(                            (mod(valAngle, 360))  - valAngleStep * (Count - 1) >= 0,              valHeight- abs(valElevation) + abs(valElevation) *  (valAngle - (mod(valAngle, 360))  + valAngleStep * (Count - 1)) / valAngle,                            valHeight- abs(valElevation) + abs(valElevation) * (valAngle - 360 - (mod(valAngle, 360)) + valAngleStep * (Count - 1)) / valAngle             )            )          ),          DrawModel3DMesh(            Model3D(1,atmC),            9,            valRadius,            0,            0,            1,            1,            if(              valElevation>0,                            valElevation + valHeight - (abs(valElevation) / valAngle)*valAngleStep * (Count-1),              if(                            (mod(valAngle, 360))  - valAngleStep * (Count - 1) >= 0,              valHeight- abs(valElevation) + abs(valElevation) *  (valAngle - (mod(valAngle, 360))  + valAngleStep * (Count - 1)) / valAngle,                            valHeight- abs(valElevation) + abs(valElevation) * (valAngle - 360 - (mod(valAngle, 360)) + valAngleStep * (Count - 1)) / valAngle             )            )          ),          popCoords        )      )      )    )  ))], [Draws the conveyor out of 3D meshes. e(1) is a pointer to the curved conveyor that needs to be drawn.], [NAC_Conveyor_Curved_Right_3D(c)], 0, [Right Curved NonAccumulating Conveyor.atm]);
DefineFunction([NAC_Curved_Right_Old], [Conveyors], 1, 1, [do(  var([atmC], vbAtom),    atmC:= p(1),   att(15,atmC),  setatt(16,min(att(12,atmC),att(14,atmC)),atmC),  repeat(   /(abs(att(13,atmC)),att(17,atmC)),   do(    setatt(21,+(zsize(atmC),*(-(count,1),/(att(18,atmC),/(att(13,atmC),att(17,atmC)))),if(<(att(13,atmC),0),att(18,atmC)))),     case(      att(19,atmC),      do(       di3dbox(0,-(att(11,atmC)),0,att(20,atmC),ysize(atmC),att(21,atmC),colorsilver,att(16,atmC),/(att(17,atmC),2)),       di3dbox(0,-(att(11,atmC)),att(21,atmC),att(20,atmC),-0.05,0.1,color,att(16,atmC),/(att(17,atmC),2)),       di3dbox(0,-(ysize(atmC),att(11,atmC)),att(21,atmC),att(20,atmC),0.05,0.1,color,att(16,atmC),/(att(17,atmC),2))      ),      do(       if(<(mod(-(count,1),*(/(/(abs(att(13,atmC)),att(17,atmC)),att(7,atmC)),att(24,atmC))),1),        do(         di3dbox(0,-(0,att(11,atmC)),0,0.05,0.05,att(21,atmC),14473664,att(16,atmC),0),         di3dbox(0,-(ysize(atmC),att(11,atmC)),0,0.05,0.05,att(21,atmC),14473664,att(16,atmC),0)        )       ),       di3dbox(0,-(0.2,att(11,atmC)),-(att(21,atmC),0.1),att(20,atmC),-(ysize(atmC),0.4),0.07,5263440,att(16,atmC),/(att(17,atmC),2)),       di3dbox(0,-(-(ysize(atmC),0.06),att(11,atmC)),-(att(21,atmC),0.2),att(20,atmC),0.03,0.3,color,att(16,atmC),/(att(17,atmC),2)),       di3dbox(0,-(0.06,att(11,atmC)),-(att(21,atmC),0.2),att(20,atmC),0.03,0.3,color,att(16,atmC),/(att(17,atmC),2))      ),      do(       if(<(mod(-(count,1),*(/(/(abs(att(13,atmC)),att(17,atmC)),att(7,atmC)),att(24,atmC))),1),        do(         di3dbox(0,-(0,att(11,atmC)),0,0.05,0.05,att(21,atmC),14473664,att(16,atmC),0),         di3dbox(0,-(ysize(atmC),att(11,atmC)),0,0.05,0.05,att(21,atmC),14473664,att(16,atmC),0)        )       ),       repeat(        /(att(20,atmC),0.15),        di3dbox(0,-(0.17,att(11,atmC)),-(att(21,atmC),0.1),0.08,-(ysize(atmC),0.3),0.08,bernoulli(50,colorgray,colorsilver),+(att(16,atmC),*(-(count,1),/(1.125,att(20,atmC)))),0)       ),       di3dbox(0,-(-(ysize(atmC),0.06),att(11,atmC)),-(att(21,atmC),0.2),att(20,atmC),0.03,0.3,color,att(16,atmC),/(att(17,atmC),2)),       di3dbox(0,-(0.06,att(11,atmC)),-(att(21,atmC),0.2),att(20,atmC),0.03,0.3,color,att(16,atmC),/(att(17,atmC),2))      )    ),    setatt(16,+(att(16,atmC),att(17,atmC)),atmC)   )  ),  att(22,atmC))], [Draws the conveyor out of ED 3D objects. e(1) is a pointer to the curved conveyor that needs to be drawn.], [NAC_Curved_Right_Old(c)], 0, [Right Curved Non Accumulating Conveyors.atm]);
Set(Icon(a), 
	RegisterIcon(IconsDir([bmp\atoms\conveyor.bmp]), [conveyor]));
AddModel3D(
	RegisterModel3D(Model3DDir([Industrial\Conveyors\SpiralPart1.wrl]), [SpiralPart1.wrl], 0, 0, 0, 1, 1, -1, -90, 90, 0), a);
SetMaterial(
	RegisterMaterial([Default], 8421504, 8421504, 3289650, 0, 0.100000001490116, 0, false, false, 1, 0), 1, a);
Set(Version(a), 8);
SetTreeIcon(pDir([Media\Icons\Curved Non AccumulatingConveyor.ico]));
Set(Info, [A non-accumulating conveyor curve. 

General
------------
If an atom enters, the conveyor closes the inputchannels. 
When the atom that entered is conveyed by the 
pre-entered product length, the input opens again.

The atom is conveyed up to the end of the conveyor as 
long as the front most atom is not blocked.  If an atom 
reaches the end of the conveyor it is moved out.

The speed in m/s can be specified. When the atom 
that entered is conveyed far enough,  the input opens 
again. 

The user can specify a speed, radius, starting angle, total 
angle and elevation.

The total angle may exceed 360 degrees, but 
this is generally only usefull if it has an elevation <> 0
(spiral up). The length of the conveyor is calculated 
automatically from its radius, total angle and elevation.

It is possible to change the position of conveyor on z axis with use of GUI. Z offset.

Width of the conveyor can be change now also in GUI.

REMARK:
---------------
If you have changed the conveyor size: first press reset 
before simulating.



Statuses:
--------------
  13 - Empty
  26 - Conveying
    5 - Blocked


Last revision:
-------------------
November, 4, 2008
]);
SetChannels(1, 1);
SetChannelRanges(1, 255, 1, 255);
int001(44);
SetLoc(1, 0, 0);
SetSize(1, 1, 1);
LockPosition(false);
LockSize(false);
DisableIconRotation(false);
SetProductCode([]);
CreateAttributes(35);
SetAttributeName(r(1), [speed]);
SetAttributeName(r(2), [horspeed]);
SetAttributeName(r(3), [input_length]);
SetAttributeName(r(4), [curloc]);
SetAttributeName(r(5), [IsConveyor]);
SetAttributeName(r(6), [notused]);
SetAttributeName(r(7), [length]);
SetAttributeName(r(8), [sendto]);
SetAttributeName(r(9), [notused]);
SetAttributeName(r(10), [notused]);
SetAttributeName(r(11), [radius]);
SetAttributeName(r(12), [startangle]);
SetAttributeName(r(13), [angle]);
SetAttributeName(r(14), [endangle]);
SetAttributeName(r(15), [setanglestep]);
SetAttributeName(r(16), [curangle]);
SetAttributeName(r(17), [anglestep]);
SetAttributeName(r(18), [elevation]);
SetAttributeName(r(19), [3diconcode]);
SetAttributeName(r(20), [iconlength]);
SetAttributeName(r(21), [curzsize]);
SetAttributeName(r(22), [calc locations]);
SetAttributeName(r(23), [entrytrigger]);
SetAttributeName(r(24), [legspacing]);
SetAttributeName(r(25), [lengthcalc]);
SetAttributeName(r(26), [exittrigger]);
SetAttributeName(r(27), [totblocked]);
SetAttributeName(r(28), [blocked]);
SetAttributeName(r(29), [inputopen]);
SetAttributeName(r(30), [tmp]);
SetAttributeName(r(31), [spacingrule]);
SetAttributeName(r(32), [spacing]);
SetAttributeName(r(33), [leadtimea]);
SetAttributeName(r(34), [leadtimeb]);
SetAttributeName(r(35), [IsConveyor]);
SetExprAtt(r(1), [1]);
SetExprAtt(r(2), [att(1,c)]);
SetExprAtt(r(4), [-(*(att(1,c),-(-(time,entrytime(cs)),-(att(30,c),ddb([t-blck],cs)))),0)]);
SetAtt(r(5), 10);
SetAtt(r(7), 7.853981634);
SetExprAtt(r(8), [1]);
SetExprAtt(r(11), [5]);
SetAtt(r(13), 90);
SetExprAtt(r(14), [+(att(12,c),att(13,c))]);
SetExprAtt(r(15), [do(setatt(17,10,c),setatt(20,*(*(att(11,c),att(17,c)),0.017444444),c))]);
SetAtt(r(19), 2);
SetExprAtt(r(22), [ if(  <>(content(c),0),  do(   setatt(30,+(att(27,c),if(>(att(28,c),0),-(time,att(28,0)),0)),c),   foratomlayerunder(    c,    do(     setcs,     if(      (time- EntryTime(cs)) * att([Speed], c) < xsize(cs),      do(        set(RotationAc(cs), att([Startangle], c)),                  setloc(-(xSize(cs)) + (time- EntryTime(cs)) * att([Speed], c), -(-(/(ysize(c), 2), /(ysize(cs), 2)), att([radius], c)), +(*(att([elevation], c),/(att([curloc], c), att([length], c))), zsize(c)),cs)                         ),            do(       set(RotationAs(cs), -(ArcTan((xSize(cs) /2) /((ySize(c) / 2)- att([radius],c))) * (att([curloc], c) - xSize(cs))/ (att([length], c)-xSize(cs)))),             set(RotationAc(cs),  att([Startangle], c) + (att([angle], c) + ArcTan((xSize(cs)) /((ySize(c) / 2)- att([radius],c))) )* (att([curloc], c) - xSize(cs))/ (att([length], c)-xSize(cs))),                            setloc(0, -(-(/(ysize(c), 2), /(ysize(cs), 2)), att([radius], c)), +(*(att([elevation], c) ,/(att([curloc], c), att([length], c))), zsize(c)),cs)        )           )    )   )  ) )]);
SetAtt(r(24), 1);
SetExprAtt(r(25), [SQRT( +(  SQR(*(*(0.01745329252,abs(ATT(13,C))),att(11,c))),  SQR(att(18,c)) ))]);
SetAtt(r(31), 1);
SetAtt(r(35), 10);
int024;
Set(OnEvent, [case(eventcode, { 1 : open the input again } if( att(28,c)=0,  do(    setatt(29,1,c),    openallic(c)  ) ), { 2 : send on the product } do(  closeallic(c),  setatt(28,time,c),  setstatus(5,c),  openalloc(c) ))]);
Set(OnEntered, [do( closeallic(c), setstatus(26,c), setatt(29,0,c), sddb([t-blck],att(27,c),i), if(=(content(c),1),   createevent(/(att(7,c),att(1,c)),c,2) ), { Check if this product can be on conveyor entirely } if(   <(    /(productspacing(att(31,c),xsize(i),att(32,c)),att(1,c)),    max(-(/(att(7,c),att(1,c)),-(-(time,entrytime(first(c))),-(att(27,c),ddb([t-blck],first(c))))),0)   ),  createevent(/(productspacing(att(31,c),xsize(i),att(32,c)),att(1,c)),c,1) ), {entrytrigger} att(23,c))]);
Set(OnExited, [do( closealloc(c), set(rotationac(i),0), set(rotationas(i),0), setatt(27,+(att(27,c),-(time,att(28,c))),c), { still to move: total moving time - ( (time-entrytime) - (totblocked nu - totblocked enter) ) } if(>(content(c),0),  do(   createevent(max(-(/(att(7,c),att(1,c)),-(-(time,entrytime(first(c))),-(att(27,c),ddb([t-blck],first(c))))),0),c,2),   { check if input is open, if not create an event in x time }   if(att(29,c),    createevent(0,c,1),    do(      if( <(max(-(/(productspacing(att(31,c),xsize(last(c)),att(32,c)),att(1,c)),-(-(time,entrytime(last(c))),-(att(27,c),ddb([t-blck],last(c))))),0),            max(-(/(att(7,c),att(1,c)),-(-(time,entrytime(first(c))),-(att(27,c),ddb([t-blck],first(c))))),0)           ),        createevent(max(-(/(productspacing(att(31,c),xsize(last(c)),att(32,c)),att(1,c)),-(-(time,entrytime(last(c))),-(att(27,c),ddb([t-blck],last(c))))),0),c,1)      )    )   ),   setstatus(26,c)  ),  do(   setatt(27,0,c),   createevent(0,c,1),   setstatus(13,c)  ) ), sddb([t-blck],0,i), setatt(28,0,c), {exittrigger} att(26,c))]);
Set(OnCreation, [do( autoconnect, setstatus(1,c),   var([valRadius], vbValue, att([Radius], c)), var([valLegSpacing], vbValue, att([legspacing], c)), var([valAngle], vbValue, att([angle],c)), att([AngleStep], c) := valLegSpacing * 180 / (pi * valRadius), Label([NumberOfSupports],c) := Round(Max(1, trunc((min(abs(valAngle), 360)/att([AngleStep], c)))),0) + 1)]);
Set(OnReset, [do(  closealloc(c), setstatus(13,c), setatt(27,0,c), setatt(28,0,c), setatt(29,0,c), setatt(7,att(25,c),c),{// input length, both input length and horspeed are not used in this atom but necessary for use with Merge atom//} setatt(3, *(2,pi,att(11,c),/(abs(att(13,c)),360)),c), if(  att([legspacing], c) > 0,  do(   var([valRadius], vbValue, att([Radius], c)),   var([valLegSpacing], vbValue, att([legspacing], c)),   var([valAngle], vbValue, att([angle],c)),       att([AngleStep], c) := valLegSpacing * 180 / (pi * valRadius),   Label([NumberOfSupports],c) := Round(Max(1, trunc((min(abs(valAngle), 360)/att([AngleStep], c)))),0) + 1   ) ))]);
Set(OnUser, [Do(  { Delete any current instances of this form.}   GuiDestroy([RCNAC]),  { Register the GUI-form for this atom.}  GuiRegister(PDir([\Atoms\Right Curved Non Accumulating Conveyor.gui]), 1),  { Show the GUI-form.}   GuiCreate([frmRightCurvedNonAccumulatingConveyor], [RCNAC], 0, c, 0, 1) )]);
Set(OnOcReady, [if( >(content(c),0),  moverequest(first(c),att(8,c)))]);
Set(On2DDraw, [do(
 att([calc locations], c),
 
 PushCoords,
 RotateCoords(att([StartAngle], c)),
 
 diarc(0, 0, att([radius], c), 0, att([angle], c), color),
 diarc(0, 0, att([radius], c) - ysize(c), 0, att([angle], c), color),
 
 DrawArrow(0.15,   - (att([radius], c)) + 0.5 * ysize(c),0.25, - (att([radius], c)) + 0.5 * ysize(c), 0.15, 0.15, Color(c), True, 100, 0),

 
 PopCoords
)
]);
Set(On3DDraw, [If(
  Model3D(1, c) > 0,
  Do(
    att([calc locations],c),
    NAC_Conveyor_Curved_Right_3D(c)
  ),
  NAC_curved_Right_Old(c)
)
]);
SetStatus(1);
int018;
int007;
