

{Atom: Accumulating Conveyor}

sets;
BaseClass;
CreateAtom(a, s, [], 1, false);
int023([Accumulating Conveyor], 11249415, 1266);
Set(Icon(a), 
	RegisterIcon(IconsDir([bmp\atoms\conveyor.bmp]), [conveyor]));
SetMaterial(
	RegisterMaterial([Default], 8421504, 8421504, 3289650, 0, 0.100000001490116, 0, false, false, 1, 0), 1, a);
Set(Version(a), 8);
SetTreeIcon(pDir([Media\Icons\AccumulatingConveyor.ico]));
Set(Info, [Accumulating conveyor.

General
------------
If an atom enters, the conveyor closes the input channels. When the 
atom that entered is conveyed by its length the input 
opens again. The product is conveyed up to the end of the conveyor 
or until it reaches another atom (distance depends on length of products 
and defined spacing). The speed in m/s can be specified. The 
capacity of the conveyor equal its length in meters or the capacity 
you entered.

REMARK:
---------------
If you have changed the conveyor size: first press reset before simulating.
If you need to model a lot of conveyors, better 
use the Fast Non Accumulating conveyor.

Z loc can be also changed in Gui.

Statuses:
-------------
  13 - Empty
  26 - Conveying
    5 - Blocked

Last revision:
-------------------
November,5, 2008
]);
SetChannels(1, 1);
SetChannelRanges(1, 255, 1, 255);
int001(38);
SetSize(10, 1, 1);
LockPosition(false);
LockSize(false);
DisableIconRotation(false);
SetProductCode([]);
CreateAttributes(24);
SetAttributeName(r(1), [Speed]);
SetAttributeName(r(2), [TravelTimeC]);
SetAttributeName(r(3), [TempMaxLoc]);
SetAttributeName(r(4), [CurLoc]);
SetAttributeName(r(5), [ExitTime]);
SetAttributeName(r(6), [CurContent]);
SetAttributeName(r(7), [Length]);
SetAttributeName(r(8), [SendTo]);
SetAttributeName(r(9), [TimeOfEntry]);
SetAttributeName(r(10), [ExitLength]);
SetAttributeName(r(11), [CalcLocations]);
SetAttributeName(r(12), [EntryTrigger]);
SetAttributeName(r(13), [Capacity]);
SetAttributeName(r(14), [SpacingRule]);
SetAttributeName(r(15), [Spacing]);
SetAttributeName(r(16), [ExitTrigger]);
SetAttributeName(r(17), [Use_Physical]);
SetAttributeName(r(18), [Input_Length]);
SetAttributeName(r(19), [Display_Factor]);
SetAttributeName(r(20), [Leg_Supports]);
SetAttributeName(r(21), [Elevation]);
SetAttributeName(r(22), [Angle]);
SetAttributeName(r(23), [Hor_Length]);
SetAttributeName(r(24), [IsConveyor]);
SetAtt(r(1), 1);
SetExprAtt(r(2), [Length / Speed]);
SetExprAtt(r(4), [Min(TempMaxLoc, Speed * (Time - EntryTime(cs)))]);
SetExprAtt(r(7), [If(Elevation <> 0,   Hor_Length / Cos(Angle), Hor_Length)]);
SetExprAtt(r(8), [1]);
SetExprAtt(r(11), [If(Content(c) <> 0,   Do(   TempMaxLoc :=Min(Length, +((Length - ExitLength), (Speed * (Time - ExitTime)))),   ForAtomLayerUnder(c, Do(     Setcs,     SetLoc(-(*(Display_Factor, CurLoc), xSize(cs)), /(-(ySize(c), ySize(cs)), 2), +(zSize(c), *(/(CurLoc, /(If(Use_Physical, xSize(c), Input_Length), xSize(c))), Sin(Angle))), cs),     SetAtt(3, -(TempMaxLoc, ProductSpacing(SpacingRule, xSize(cs), Spacing)), c)    )   )  ) )]);
SetAtt(r(13), 10000);
SetAtt(r(14), 1);
SetAtt(r(17), 1);
SetAtt(r(18), 10);
SetAtt(r(20), 3);
SetExprAtt(r(21), [0]);
SetExprAtt(r(22), [ArcTan(Elevation / Hor_Length)]);
SetExprAtt(r(23), [If(Use_Physical, xSize(c),    Input_Length)]);
SetAtt(r(24), 5);
int024;
Set(OnEvent, [Case(  EventCode,  { 1 }  Do(Status(c) := 5,        OpenAllOc(c)),  { 2 }  If(Content(c) = 0,     OpenAllIc(c),     If(      And(       (CurContent < Length),        (Content(c) < Capacity),        <=(        ProductSpacing(SpacingRule, xSize(Last(c)), Spacing) / Speed,        {(xSize(Last(c)) / Speed), }                        ((Time - EntryTime(Last(c))) + 0.00001)       )      ),      OpenAllIc(c)     )  ))]);
Set(OnEntered, [Do( TimeOfEntry := Time, CurContent := CurContent + ProductSpacing(SpacingRule, xSize(i), Spacing), CloseAllIc(c), EntryTrigger, If(Content(c) = 1,    Do(Status(c) := 26,          CreateEvent(TravelTimeC, c, 1, 1, i)    )   ), If(CurContent < Length,    CreateEvent(ProductSpacing(SpacingRule, xSize(i), Spacing) / Speed, c, 2)   ))]);
Set(OnExited, [Do( CurContent := CurContent - ProductSpacing(SpacingRule, xSize(i), Spacing), CloseAllOc(c), ExitTime := Time, ExitLength := ProductSpacing(SpacingRule, xSize(i), Spacing), If(Content(c) <> 0,    Do(      CreateEvent(        Max(/(ProductSpacing(SpacingRule, xSize(i), Spacing), Speed), -(TravelTimeC, -(Time, EntryTime(First(c))))),        c, 1, 1, First(c)),      If(And(CurContent < Length, Content(c) < Capacity),        CreateEvent(          Max(0, Max(            /(-(+(ProductSpacing(SpacingRule, xSize(i), Spacing), CurContent), Length), Speed),            -(/(xSize(Last(c)), Speed), -(Time, TimeOfEntry)))          ), c, 2)       ),      Status(c) := 26    ),   Do(     Status(c) := 13,     CreateEvent(0, c, 2)    )  ), ExitTrigger)]);
Set(OnCreation, [do( AutoConnect,  {Legs} If(Leg_Supports > 0,  label([LegDist], c) :=Trunc(xSize(c) / Leg_Supports)     ))]);
Set(OnReset, [Do(
  If(Not(Use_Physical),
     Display_Factor := xSize(c) / Input_Length,
     Display_Factor := 1),
  If(Elevation <> 0,
     Display_Factor := Display_Factor * Cos(Angle)),
  CloseAllOc(c),
  Status(c) := 13,
  ExitTime := 0,
  CurContent := 0,
  TimeOfEntry := 0,
  
  {Legs}
 If(label([LegDist], c) > 0,
 
   Leg_Supports :=Trunc(xSize(c) / label([LegDist], c)) + 1,
    
   Leg_Supports := 0)

  
  
)
]);
Set(OnUser, [Do(  { Delete any current instances of this form.}   GuiDestroy([Accumulating Conveyor]),  { Register the GUI-form for this atom.}  GuiRegister(PDir([\Atoms\Accumulating Conveyor.gui]), 1),  { Show the GUI-form.}   GuiCreate([Accumulating Conveyor], [Accumulating Conveyor], 0, c, 0, 1) )]);
Set(OnOcReady, [If(Content(c) <> 0,   MoveRequest(First(c), SendTo))]);
Set(On2DDraw, [CalcLocations]);
Set(On3DDraw, [If(  BoxVisible(0, 0, 0, xSize(c), ySize(c), zSize(c)),  If(Elevation = 0,    Do(      If(ySize(c) > 0.5, {side supports}        Do(          di3DBox(0, -0.16, zSize(c) - 0.1, xSize(c), 0.16, 0.1, Color(c), 0),          di3DBox(0, ySize(c), zSize(c) - 0.1, xSize(c), 0.16, 0.1, Color(c), 0)        ),        Do(          di3DBox(0, -0.03, zSize(c) - 0.1, xSize(c), 0.01, 0.1, Color(c), 0),          di3DBox(0, ySize(c), zSize(c) - 0.1, xSize(c), 0.01, 0.1, Color, 0)        )      ),            If(Label([LegDist], c) > 0, {leg supports}    Do(     var([valLegDist], vbValue, Label([LegDist], c) ),     Repeat(Leg_Supports,      Do(       di3DBox(xSize(c) - (*(Count - 1, valLegDist)), -0.05, 0, 0.05, 0.05, zSize(c)- 0.05, 14473664, 0),       di3DBox(xSize(c) - (*(Count - 1, valLegDist)), ySize(c), 0, 0.05, 0.05, zSize(c)- 0.05, 14473664, 0),       If(zSize(c) > 0.3,        di3DBox(xSize(c) - (*(Count - 1, valLegDist)), 0, -(zSize(c), 0.3)- 0.05, 0.03, ySize(c), 0.03, Color(c), 0)       )      )     )    )      ),      Repeat(xSize(c) * 3, {cross beams}        Do(          di3DBox(Count * 0.333-0.2, 0, zSize(c) - 0.05, 0.03, ySize(c), 0.03, ColorSilver, 0),          di3DBox(Count * 0.333-0.2, 0.1, zSize(c) - 0.05, 0.06, ySize(c) - 0.2, 0.06, ColorWhite, 0)        )      ),      CalcLocations    ),    Do(      Box(0, -0.06, zSize(c) - 0.1, /(xSize(c), Cos(Angle)), 0.06, 0.1, 0, Angle, 0, Color),      Box(0, ySize(c), zSize(c) - 0.1, /(xSize(c), Cos(Angle)), 0.06, 0.1, 0, Angle, 0, Color),            Repeat(Length * 3, {cross beams}        Do(          di3DBox(*(Count * 0.333-0.2,cos(Angle)),0, +(zsize(c), *(Count * 0.333-0.2,sin(Angle)) - 0.05), 0.03, ySize(c), 0.03, ColorSilver, 0),          di3DBox(*(Count * 0.333-0.2,cos(Angle)),0.1,+(zsize(c),*(Count * 0.333-0.2,sin(Angle)) - 0.05), 0.06, ySize(c) - 0.2, 0.06, ColorWhite, 0)        )      ),           If(Label([LegDist], c) > 0, {leg supports}    Do(     var([valLegDist], vbValue, Label([LegDist], c)),     Repeat(Leg_Supports,       Do(              di3DBox(xSize(c)- 0.05 - (*(Count - 1, valLegDist)), -0.05, 0, 0.05, 0.05, (zSize(c) + Elevation)- (Count - 1) * valLegDist* tan(Angle)- 0.05, 14473664, 0),       di3DBox(xSize(c)- 0.05 - (*(Count - 1, valLegDist)), ySize(c), 0, 0.05, 0.05, (zSize(c) + Elevation) - (Count - 1) * valLegDist* tan(Angle)- 0.05, 14473664, 0),       di3DBox(xSize(c)- 0.05 - (*(Count - 1, valLegDist)), 0, -((zSize(c) + Elevation) - (Count - 1) * valLegDist* tan(Angle), 0.3)- 0.05, 0.03, ySize, 0.03, Color, 0)      )     )    )      ),      CalcLocations    )  ))]);
SetStatus(0);
int018;
int007;
