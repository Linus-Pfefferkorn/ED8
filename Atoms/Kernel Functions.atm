

{Preregister functions}

PreregisterFunction([KernelFnc], 1, 1);
PreregisterFunction([TedFnc], 1, 1);
PreregisterFunction([AutoConnect], 0, 0);
PreregisterFunction([Int023Atom], 1, 1);
PreregisterFunction([Int023Atm], 2, 2);
PreregisterFunction([Int023Icon], 2, 2);
PreregisterFunction([Int023VRIcon], 2, 2);
PreregisterFunction([Int023VRSound], 2, 2);
PreregisterFunction([AutoLoadIcon], 2, 2);
PreregisterFunction([MakeFileName], 2, 2);
PreregisterFunction([GetLicenseTypeString], 0, 0);
PreregisterFunction([UpdatemodelName], 1, 1);
PreregisterFunction([SimplifyName], 0, 0);
PreregisterFunction([createmodelLayout], 0, 8);
PreregisterFunction([IsmodelLayoutVisible], 0, 1);
PreregisterFunction([ClosemodelLayout], 0, 1);
PreregisterFunction([ForAllmodelLayouts], 1, 1);
PreregisterFunction([UpdatemodelLayouts], 0, 0);
PreregisterFunction([createmodelView], 0, 7);
PreregisterFunction([IsmodelViewVisible], 0, 1);
PreregisterFunction([ClosemodelView], 0, 1);
PreregisterFunction([ForAllmodelViews], 1, 1);
PreregisterFunction([Is3DmodelViewVisible], 0, 1);
PreregisterFunction([ForAll3DmodelViews], 1, 1);
PreregisterFunction([create3DmodelView], 1, 1);
PreregisterFunction([Close3DmodelView], 0, 1);
PreregisterFunction([SearchStringInCode], 1, 3);
PreregisterFunction([Divide], 2, 2);
PreregisterFunction([StandardEditStyle], 0, 0);
PreregisterFunction([StandardDisplay], 1, 4);
PreregisterFunction([Draw2DIcon], 1, 4);
PreregisterFunction([Di3DFrame], 15, 15);
PreregisterFunction([ShowSamplemodel], 1, 8);
PreregisterFunction([CopyAtomTableToGui], 2, 2);
PreregisterFunction([Ted2000Fnc], 1, 1);
PreregisterFunction([ProductSpacing], 3, 3);
PreregisterFunction([GetCornerSpeed], 1, 1);
PreregisterFunction([GetSendToTransporter], 1, 1);
PreregisterFunction([GetSendTo], 1, 1);
PreregisterFunction([GetSendToCrane], 1, 1);
PreregisterFunction([GetInputStrategy], 1, 1);
PreregisterFunction([GetSetupTime], 1, 1);
PreregisterFunction([GetDistributionOptions], 0, 0);
PreregisterFunction([GetMCBF], 0, 0);
PreregisterFunction([GetTriggerEnterExit], 0, 0);
PreregisterFunction([GetNumberOfProducts], 1, 1);
PreregisterFunction([GetCreationTrigger], 1, 1);
PreregisterFunction([GetQueueDiscipline], 1, 1);
PreregisterFunction([GetDefaultSpeed], 0, 0);
PreregisterFunction([GetResponse], 0, 0);
PreregisterFunction([GetPFM], 0, 0);
PreregisterFunction([GetVariable], 0, 0);
PreregisterFunction([GetObjective], 0, 0);
PreregisterFunction([GetRequirement], 0, 0);
PreregisterFunction([GetUserAction], 0, 0);
PreregisterFunction([GetAtomReference], 0, 0);
PreregisterFunction([GetUnpackQuantity], 0, 0);
PreregisterFunction([GetPut], 0, 1);
PreregisterFunction([GetOffset], 1, 1);
PreregisterFunction([GetOperatorRule], 1, 1);
PreregisterFunction([GetAtomSelection], 1, 1);
PreregisterFunction([GetAnaysisTime], 0, 0);
PreregisterFunction([GetGraphValue], 1, 1);
PreregisterFunction([GetGraphLabel], 0, 0);
PreregisterFunction([GetMeasuringUnit], 1, 1);
PreregisterFunction([GetRepeatTime], 1, 1);
PreregisterFunction([GetAtomSelectionRule], 1, 1);
PreregisterFunction([GetRowSelectionRule], 1, 1);
PreregisterFunction([GetLabel], 1, 1);
PreregisterFunction([GetSort], 1, 1);
PreregisterFunction([GetDispatchTo], 1, 1);
PreregisterFunction([GetMovement], 1, 1);
PreregisterFunction([GetMovement2], 1, 1);
PreregisterFunction([GetProductStatistics], 1, 1);
PreregisterFunction([GetProductCriteria], 1, 1);
PreregisterFunction([GetObjectivesOrRequirements], 1, 1);
PreregisterFunction([GetHistoryViewerStartTimes], 0, 0);
PreregisterFunction([GetHistoryViewerEndTimes], 0, 0);
PreregisterFunction([GetAutofitDataExpression], 1, 1);
PreregisterFunction([t-GetSetUpCode], 2, 2);
PreregisterFunction([t-FindQueuePos], 2, 2);
PreregisterFunction([UpdateCameraMenuItems], 0, 0);
PreregisterFunction([AddCameraMenuItem], 3, 4);
PreregisterFunction([GetTriggerReset], 0, 0);
PreregisterFunction([GetTriggerBreakdown], 0, 0);
PreregisterFunction([GetTriggerEndOfSetup], 0, 0);
PreregisterFunction([GetTriggerRepair], 0, 0);
PreregisterFunction([GetTriggerLoadUnload], 0, 0);
PreregisterFunction([GetSendToIntersections], 1, 1);
PreregisterFunction([GetSendToSpeedChangeAccConv], 1, 1);
PreregisterFunction([Functions_Cut], 1, 1);
PreregisterFunction([Functions_Paste], 1, 1);
PreregisterFunction([AtomTreePaste_withFunctions], 1, 1);
PreregisterFunction([AtomTreeCut_withFunctions], 0, 0);
PreregisterFunction([createviewermodelLayout], 0, 8);
PreregisterFunction([createviewermodelView], 0, 7);
PreregisterFunction([createviewer3DmodelView], 1, 1);
PreregisterFunction([FillPredefinedLogicList], 2, 2);


{Atom: Kernel Functions}

sets;
BaseClass;
CreateAtom(a, s, [], 1, false);
Set(OnInit, [Do( RegisterEditField(  [DdbTex],  [Dynamic Database],  [Ddb(CurFieldName, a, 2)],[sDdb(CurFieldName, &)],  FieldText(0, 1000),  [Edit an dynamic database text]))]);
int023([Kernel Functions], 0, 0);
DefineFunction([KernelFnc], [Various], 1, 1, [{ --- Old function called a file section --- }Do( ExecFileSection(pdir([kernel.fnc]), p(1)))], [Shortcut to calling an ExecFileSection in the file kernel.fnc], [KernelFnc([create model])], 0, [Kernel Functions.atm]);
DefineFunction([TedFnc], [Various], 1, 1, [{ --- Old function called a file section --- }KernelFnc(p(1))], [Shortcut to calling an ExecFileSection in the file kernel.fnc], [TedFnc([create model])], 0, [Kernel Functions.atm]);
DefineFunction([AutoConnect], [modeler], 0, 0, [Do( If(  And(   AtomExists(prev(c)),   >(    nroc(prev(c)), 0   ),   not(    AtomExists(out(1,prev(c)))   )  ),  Connect(1,prev(c), 1, c) ))], [Use this in oncreate eventhandlers to automatically connect channels.], [AutoConnect], 0, [Kernel Functions.atm]);
DefineFunction([Int023Atom], [Internal], 1, 1, [{--- Originating from Kernel Functions.atm ---Do( If(not(AtomExists(AtomByName(p(1), Main))),  If(FileExists(pdir(Concat([atoms\], p(1), [.atm]))),   Do(    Library,    ExecFile(pdir(Concat([atoms\], p(1), [.atm])))   ),   Do(    DisplayTracer,    Trace(Concat([File ], p(1), [.atm not found]))   )  ) ))}{--- Originating from ED.4DS --- }Do( If(not(AtomExists(AtomByName(p(1),Main))),  If(FileExists(pdir(Concat([atoms\], p(1), [.atm]))),   Do(    If(AtomExists(AtomByName([AUTOLOADED],library)),     sets,     sets(library)    ),    s,    ExecFile(pDir(Concat([atoms\],p(1),[.atm])))   ),   Do(    DisplayTracer,    Trace(concat([File ],p(1),[.atm not found]))   )  ) ))], [Checks if atom e1 exists, if not it is loaded.], [Int023Atom], 0, [Kernel Functions.atm]);
DefineFunction([Int023Atm], [Internal], 2, 2, [{--- Originating from Kernel Functions.atm ---Do( If(not(AtomExists(AtomByName(p(2), Main))),  If(FileExists(p(1)),   Do(    Library,    ExecFile(p(1))   ),   Do(    DisplayTracer,    Trace(Concat([File ], p(1), [ not found]))   )  ) ))}{--- Originating from ED.4DS --- }Do( If(not(AtomExists(AtomByName(p(2),Main))),  If(FileExists( p(1) ),   Do(    If(AtomExists(AtomByName([AUTOLOADED],Library)),     Sets,     Sets(Library)    ),    s,    ExecFile(p(1))   ),      Do(    DisplayTracer,    Trace(Concat([File ],p(1),[ not found]))   )  ) ))], [Checks if atom e1 exists, if not it is loaded.], [Int023Atm], 0, [Kernel Functions.atm]);
DefineFunction([Int023Icon], [Internal], 2, 2, [Do( Icon :=(  If(not(IconExists( p(2))),   RegisterIcon( p(1), p(2)),   IconByName( p(2) )  ) ))], [Assigns e2 to the currently active atom, if e2 does not exist it is loaded.], [Int023Icon], 0, [Kernel Functions.atm]);
DefineFunction([Int023VRIcon], [Internal], 2, 2, [Do( Vricon := (  If(not(vrIconExists( p(2) )),   RegisterVRIcon(p(1), p(2) ),   vrIconByName( p(2) )  ) ))], [Assigns e2 to the currently active atom, if e2 does not exist it is loaded.], [Int023VRIcon], 0, [Kernel Functions.atm]);
DefineFunction([Int023VRSound], [Internal], 2, 2, [Do( Vrsound := (  If(not(vrSoundExists( p(2) )),   RegisterVRSound( p(1), p(2) ),   vrSoundByName( p(2) )  ) ))], [Assigns e2 to the currently active atom, if e2 does not exist it is loaded.], [Int023VRSound], 0, [Kernel Functions.atm]);
DefineFunction([AutoLoadIcon], [Various], 2, 2, [Do( If(not(IconExists( p(2) )),  RegisterIcon( p(1), p(2) ) ))], [Loads icon e1 if an icon with name e2 does not yet exist.], [AutoLoadIcon], 0, [Kernel Functions.atm]);
DefineFunction([MakeFileName], [Various], 2, 2, [Do( Set(gString(1), p(1) ), Set(gString(2), p(2) ), If(  CompareText(gString(1), []),  [],  If(   CompareText(ExtractName(gString(1)), Fileprename(gString(1))),   Concat(gString(1),gString(2)),   gString(1)  ) ))], [Generates a filename that always includes extension e2 using e1 as a basis. e1 may or may not have an extension.], [MakeFileName([mymod.atm], [.mod])], 0, [Kernel Functions.atm]);
DefineFunction([GetLicenseTypeString], [Various], 0, 0, [Do( Case(  GetLicenseType,   {1} [Enterprise Dynamics® - TAMPERED LICENSE!!!! PLEASE CONTACT ENTERPRISE DYNAMICS TO OBTAIN A VALID LICENSE!! - ],   {2} [Enterprise Dynamics® Evaluation License - ],   {3} [Enterprise Dynamics® Student License - ],   {4} [Enterprise Dynamics® Runtime License - ],   {5} [Enterprise Dynamics® Educational Single License - ],   {6} [Enterprise Dynamics® Full License - ],   {7} [Enterprise Dynamics® Unlicensed - ],   {8} [Enterprise Dynamics® All License - ],   {9} [Enterprise Dynamics® Education Classroom License - ],  {10} [Enterprise Dynamics® License Expired - ],  {11} [Enterprise Dynamics® Bizmodel License - ],  {12} [Enterprise Dynamics® ECONOMY - ],  {13} [Enterprise Dynamics® STUDIO - ],  {14} [Enterprise Dynamics® FALCON - ],  {15} [Enterprise Dynamics® VIEWER - ],  {16} [Enterprise Dynamics® Factory Suite - ],  {17} [Enterprise Dynamics® Educational Suite - ],  {18} [Enterprise Dynamics® Warehouse Simulator - ],  {19} [Enterprise Dynamics® Builder - ],  {20} [Enterprise Dynamics® Developer - ],  {21} [Pedestrian Dynamics® Evaluation License - ],  {22} [Pedestrian Dynamics® - ],  {23} [Pedestrian Dynamics® Educational Single License - ],  {24} [Pedestrian Dynamics® Education Classroom License - ],  {25} [Pedestrian Dynamics® Builder - ] ))], [Returns a string of the License Type.], [GetLicenseTypeString], 0, [Kernel Functions.atm]);
DefineFunction([UpdatemodelName], [Various], 1, 1, [Do( Settextatt(1, p(1), model), Set(title, Concat(GetLicenseTypeString, Ddb([menutitle], Main), [ ], p(1) )), model)], [Stores e1 in model attribute 1 and Sets the title.], [UpdatemodelName], 0, [Kernel Functions.atm]);
DefineFunction([SimplifyName], [Various], 0, 0, [Do( If(  And(   >(StringLength(Name(TreeAtom)), 5),   CompareText([T], StringCopy(Name(TreeAtom), 1, 1))  ),    If(   CompareText([-], StringCopy(Name(TreeAtom), 7, 1)),   StringCopy(Name(TreeAtom), 8,-(StringLength(Name(TreeAtom)), 7)),    If(     CompareText([-],StringCopy(Name(TreeAtom), 5, 1)),     StringCopy(Name(TreeAtom), 6,-(StringLength(Name(TreeAtom)), 5)),     Name(TreeAtom)    )  ),  Name(TreeAtom) ))], [Returns the name of the active treeatom without the leading characters from atom names that start with TXXX- or TXXX-x-.], [SimplifyName], 0, [Kernel Functions.atm]);
DefineFunction([createmodelLayout], [Various], 0, 8, [Do( GuiRegister(pdir([Apps\modelLayout2D.GUI]), 1),  { find new model layout name } v := 0, t := Concat([modelLayout], string(v+1)), LoopUntil(GuiInstance(t) = 0,  Do(   v := v + 1,   t := Concat([modelLayout], string(v+1))  ) ),  Guicreate([modelLayout], t),  { set view atom } If (ParamCount = 0,  GuiControl([Engine2D], GuiSet([DisplayAtom], model)),  GuiControl([Engine2D], GuiSet([DisplayAtom], p(1))) ),  { position window } GUIControl([modelLayout], GUISet([Left], GetPreference([Window2D], [x]) + v * 20)), GUIControl([modelLayout], GUISet([Top], WindowHeight(Application) + 2 + v * 20)), {GetPreference([Window2D], [y]) + v * 20)),} GUIControl([modelLayout], GUISet([Width], GetPreference([Window2D], [Width]))), GUIControl([modelLayout], GUISet([Height], GetPreference([Window2D], [Height]))),  { Set the parameters passed to this function } If (ParamCount > 1,  GUIControl([Engine2D], GUIEvent([Refresh], p(2))) ), If (ParamCount > 2,  GUIControl([Engine2D], GUIEvent([AtomClick], p(3))) ), If (ParamCount > 3,  GUIControl([Engine2D], GUIEvent([AtomDrop], p(4))) ), If (ParamCount > 4,  GUIControl(0, GUISet([Caption], p(5))) ), If (ParamCount > 5,  GUIControl([Engine2D], GUISet([ShowGrid], p(6) > 0)) ), If (ParamCount > 6,  GUIControl([Engine2D], GUISet([ShowChannels], p(7) > 0)) ), If (ParamCount > 7,  GUIControl([Engine2D], GUIEvent([ViewPointChange], p(8))) ),  { set the right flags } GuiControl([MainMenu]), GuiMenuItem([mniGridEnabled], [Checked],  GuiControl([Engine2D], GuiGet([ShowGrid])) ), GuiMenuItem([mniChannelsEnabled], [Checked],  GuiControl([Engine2D], GuiGet([ShowChannels])) ), GuiMenuItem([mniChannelsEnabled], [Checked],  GuiControl([Engine2D], GuiGet([ShowChannels])) ), GuiMenuItem([mniStatusBar], [Checked],  GuiControl([Engine2D], GuiGet([ShowStatusBar])) ), GuiMenuItem([mniSnapToGrid], [Checked],  GuiControl([Engine2D], GuiGet([SnapToGrid])) ),  Case(  GuiControl([Engine2D], GuiGet([SelectionMode])),    { SM_LEVELSELECT }  Do(   GuiMenuItem([mniLevelSelect], [Checked], True),   GuiMenuItem([mniLevelSelect], [Checked], False)  ),    { SM_SELECTVISIBLE }  Do(   GuiMenuItem([mniLevelSelect], [Checked], False),   GuiMenuItem([mniLevelSelect], [Checked], True)  ) ),  GUIMenuItem([mniGridEnabled], [Checked], GUIControl([Engine2D], GUIGet([ShowGrid]))), GUIMenuItem([mniSelectVisible], [Checked], GuiControl([Engine2D], GuiGet([SelectionMode])) = SM_SELECTVISIBLE), GUIMenuItem([mniLevelSelect], [Checked], GuiControl([Engine2D], GuiGet([SelectionMode])) = SM_LEVELSELECT), GUIMenuItem([mniCustomUnit], [Checked], True), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[0.001]), If (v, do(GUIMenuItem([mniMM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[0.01]), If (v, do(GUIMenuItem([mniCM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[0.1]), If (v, do(GUIMenuItem([mniDIM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[1]), If (v, do(GUIMenuItem([mniM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[10]), If (v, do(GUIMenuItem([mniDAM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[100]), If (v, do(GUIMenuItem([mniHM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[1000]), If (v, do(GUIMenuItem([mniKM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))),  GuiMenuItem([mniBackgroundVisible], [Checked], Background2DVisible),  { show the form } GUIControl(0, GUISet([Visible], True)))], [This function creates a model layout window.], [createmodelLayout(c)], 0, [Kernel Functions.atm]);
DefineFunction([IsmodelLayoutVisible], [Various], 0, 1, [Do( Case( ParamCount + 1,  Do(   v := 0,   Repeat(256,    Do(     If( GuiInstance(Concat([modelLayout], string(Count)))  <> 0,      v := 1     )    )   ),   v  ),  Do(   v := GuiInstance(Concat([modelLayout], string(p(1)))) <> 0,   v  ) ))], [Returns true if a model layout is visible. The first parameter is an optional numeric ID indentifying a model layout window.], [IsmodelLayoutVisible], 0, [Kernel Functions.atm]);
DefineFunction([ClosemodelLayout], [Various], 0, 1, [Do( Case(ParamCount + 1,  Do(   Repeat(256,    Do(     If(      IsmodelLayoutVisible(Count),      Do(       GUIDestroy      )     )    )   )  ),     Do(   If(    IsmodelLayoutVisible(p(1)),    Do(     GUIDestroy    )   )  ) ))], [Closes the model layout window(s). The first parameter is an optional numeric ID indentifying a model layout window.], [ClosemodelLayout], 0, [Kernel Functions.atm]);
DefineFunction([ForAllmodelLayouts], [Various], 1, 1, [Do( Repeat(256,  Do(   If(    IsmodelLayoutVisible(Count),    Do(     ExecString(p(1))    )   )  ) ))], [Executes 4DScript string parameter 1 for every visible model layout. Every iteration another existing model layout window is the current GUIInstance.], [ForAllmodelLayouts([GUIControl([Engine2D], GUISet([ShowGrid], 0)) { disables the grid on all model layouts }])], 0, [Kernel Functions.atm]);
DefineFunction([UpdatemodelLayouts], [Various], 0, 0, [Do( ForAllmodelLayouts(  [   Do(    GUIControl([MainMenu]),    GUIMenuItem([mniBackgroundVisible], [Checked], Background2DVisible),    GUIMenuItem([mniGridEnabled], [Checked], GUIControl([Engine2D], GUIGet([ShowGrid]))),    GUIMenuItem([mniSelectVisible], [Checked], GuiControl([Engine2D], GuiGet([SelectionMode])) = SM_SELECTVISIBLE),    GUIMenuItem([mniLevelSelect], [Checked], GuiControl([Engine2D], GuiGet([SelectionMode])) = SM_LEVELSELECT)   )  ] ))], [Updates all model layouts with the current settings.], [UpdatemodelLayouts], 0, [Kernel Functions.atm]);
DefineFunction([createmodelView], [Various], 0, 7, [Do( GuiRegister(pdir([Apps\modelView2D.GUI]), 1),  { find new model view name } v := 0, t := Concat([modelView], string(v+1)), LoopUntil(GuiInstance(t) = 0,  Do(   v := v + 1,   t := Concat([modelView], string(v+1))  ) ),  Guicreate([modelView], t),  { set view atom } If (ParamCount = 0,  GuiControl([Engine2D], GuiSet([DisplayAtom], model)),  GuiControl([Engine2D], GuiSet([DisplayAtom], p(1))) ),  { set events } If (ParamCount > 1,  GUIControl([Engine2D], GUIEvent([Refresh], p(2))) ),  If (ParamCount > 2,  GUIControl([Engine2D], GUIEvent([AtomClick], p(3))) ),  If (ParamCount > 3,  GUIControl(0, GUISet([Caption], p(4))) ),  If (ParamCount > 4,  GUIControl([Engine2D], GUISet([ShowGrid], p(5) > 0)) ),  If (ParamCount > 5,  GUIControl([Engine2D], GUISet([ShowChannels], p(6) > 0)) ),  If (ParamCount > 6,  GUIControl([Engine2D], GUIEvent([ViewPointChange], p(7))) ),  { position window } GUIControl(0, GUISet([Left], GetPreference([Window2D], [x]) + v * 20)), GUIControl(0, GUISet([Top], GetPreference([Window2D], [y]) + v * 20)), GUIControl(0, GUISet([Width], GetPreference([Window2D], [Width]))), GUIControl(0, GUISet([Height], GetPreference([Window2D], [Height]))),  { show the form } GUIControl(0, GUISet([Visible], True)))], [creates a model view window.], [createmodelView(c)], 0, [Kernel Functions.atm]);
DefineFunction([IsmodelViewVisible], [Various], 0, 1, [Case(ParamCount + 1, Do(  v := 0,  Repeat(256,   Do(    If(GuiInstance(Concat([modelView], string(Count)))  <> 0,     v := 1    )   )  ),  v ), Do(  v := GuiInstance(Concat([modelView], string(p(1)))) <> 0,  v ))], [Returns true if a model view is visible. The first parameter is an optional numeric ID indentifying a model view window.], [IsmodelViewVisible], 0, [Kernel Functions.atm]);
DefineFunction([ClosemodelView], [Various], 0, 1, [Case(ParamCount + 1, Do(  Repeat(256,   Do(    If(     IsmodelViewVisible(Count),     Do(      GUIDestroy     )    )   )  ) ), Do(  If(   IsmodelViewVisible(p(1)),   Do(    GUIDestroy   )  ) ))], [Closes the model view window(s). The first parameter is an optional numeric ID indentifying a model view window.], [ClosemodelView], 0, [Kernel Functions.atm]);
DefineFunction([ForAllmodelViews], [Various], 1, 1, [Do( Repeat(256,  Do(   If(    IsmodelViewVisible(Count),    Do(     ExecString(p(1))    )   )  ) ))], [Executes 4DScript string parameter 1 for every visible model view. Every iteration another existing model view window is the current GUIInstance.], [ForAllmodelLayouts([GUIControl([Engine2D], GUISet([ShowGrid], 0)) { disables the grid on all model views }])], 0, [Kwernel.4DS]);
DefineFunction([Is3DmodelViewVisible], [Various], 0, 1, [Case(ParamCount + 1, Do(  v := 0,  Repeat(256,   Do(    If(     GuiInstance(Concat([modelView3D_], string(Count)))  <> 0,     v := 1    )   )  ),  v ), Do(  v := GuiInstance(Concat([modelView3D_], string(p(1)))) <> 0,  v ))], [Returns true if a 3D model view is visible. The first parameter is an optional numeric ID indentifying a 3D model view window.], [Is3DmodelViewVisible], 0, [Kernel Functions.atm]);
DefineFunction([ForAll3DmodelViews], [Various], 1, 1, [Do( Repeat(256,  Do(   If(Is3DmodelViewVisible(Count),    Do(     ExecString(p(1))    )   )  ) ))], [Executes 4DScript string parameter 1 for every visible 3D model view. Every iteration another existing 3D model view window is the current GUIInstance.], [ForAll3DmodelViews([GUIControl(0, GUISet([Width], 100)) { sets all 3D model view windows to a width of 100 pixels }])], 0, [Kernel Functions.atm]);
DefineFunction([create3DmodelView], [Various], 1, 1, [Do( GuiRegister(pdir([Apps\modelView3D.GUI]), 1),  { find new model view name } v := 0, t := Concat([modelView3D_], string(v+1)), LoopUntil(GuiInstance(t) = 0,  Do(   v := v + 1,   t := Concat([modelView3D_], string(v+1))  ) ),  Guicreate([modelView3D], t),  { position window } GUIControl([modelView3D], GUISet([Left], GetPreference([Window3D], [x]) + v * 20)), GUIControl([modelView3D], GUISet([Top], GetPreference([Window3D], [y]) + v * 20)), GUIControl([modelView3D], GUISet([Width], GetPreference([Window3D], [Width]))), GUIControl([modelView3D], GUISet([Height], GetPreference([Window3D], [Height]))),  { set right flags }  GUIControl([MainMenu]),  GuiMenuItem([mniStatusBar], [Checked],  GuiControl([Engine3D], GuiGet([ShowStatusBar])) ),  GuiMenuItem([mniTarGet], [Checked],  GuiControl([Engine3D], GuiGet([CameraMode]) = CT_TARGET) ),  GuiMenuItem([mniFreehand], [Checked],  GuiControl([Engine3D], GuiGet([CameraMode]) = CT_FREEHAND) ),  GuiMenuItem([mniFreehand], [Checked],  GuiControl([Engine3D], GuiGet([CameraMode]) = CT_FREEHAND) ),   GuiMenuItem([mniGrid], [Checked],  GuiControl([Engine3D], GuiGet([ShowGrid])) ),   GuiMenuItem([mniSelectedAtom], [Checked],  GuiControl([Engine3D], GuiGet([ShowSelectedAtom])) ),  { does user have VR support?} If(  AddOnAvailable(PT_VIRTUAL_REALITY),  Do(   GUIControl([MainMenu]),   GUIcreateMenuItem([mniVR], [mniView]),   GUIMenuItem([mniVR], [caption], [Virtual reality]),   GUIMenuItem([mniVR], [visible], true),   GUIMenuItem([mniVR], [code], [do(SetActive3d(GUIControl([Engine3D], GUIGet([ID]))), fullscreen(1, 0, 0, 0, 0, 1))])  ) ),  { set view atom } If( ParamCount = 0,  GuiControl([Engine3D], GuiSet([DisplayAtom], model)),  GuiControl([Engine3D], GuiSet([DisplayAtom], p(1))) ),  UpdateCameraMenuItems,  { show the form } GUIControl(0, GUISet([Visible], True)))], [creates a 3D model view window.], [create3DmodelView(c)], 0, [Kernel Functions.atm]);
DefineFunction([Close3DmodelView], [Various], 0, 1, [Case(ParamCount + 1, Do(  Repeat(256,   Do(    If(     Is3DmodelViewVisible(Count),     Do(      GUIDestroy     )    )   )  ) ),  Do(  If(   Is3DmodelViewVisible(p(1)),   Do(    GUIDestroy   )  ) ))], [Closes the 3D model view window(s). The first parameter is an optional numeric ID indentifying a 3D model view window.], [Close3DmodelView], 0, [Kernel Functions.atm]);
DefineFunction([SearchStringInCode], [Various], 1, 3, [Do( PushAtomPointer(s), var([strSearch], vbString, p(1)), var([valCaseSensitive], vbValue, p(2)), If(  p(3) > 0,  var([atmTree], vbatom, p(3)),  var([atmTree], vbatom, main) ), var([valCounter], vbValue), var([strCode], vbString), var([valNrMatches], vbValue), var([strEvent], vbString), var([valFoundOnAtom], vbValue), var([valTotalHits], vbValue, 0), Var([valCounter], vbValue),  TraceClear, TraceNumbers(0),  Trace(Concat([--- Searching for "], strSearch, [" in available function and atom events ---])),  If(  not(valCaseSensitive),  strSearch := Lowercase(strSearch) ),        ForAtomTreeUnder(     atmTree,     do(      Sets,      valFoundOnAtom := 0,            {**Function**}      valCounter := 1,      While(       StringLength(FunctionOnAtomName(s, valCounter)) > 0,       do(        strCode := FunctionOnAtomInfo(s, valCounter, [Code]),        if(         not(valCaseSensitive),         strCode := Lowercase(strCode)        ),       valNrMatches := SubstrCount(strCode, strSearch),       if(        valNrMatches > 0,        do(         inc(valTotalHits, valNrMatches),         if(          not(valFoundOnAtom),          do(           Trace(Concat([Atom: ], Name(s), [ (], ValueToString(s), [)])),           valFoundOnAtom := 1          )         ),                  Trace(concat(String(valNrMatches, 5, 0), [ times found in function ], FunctionOnAtomName(s, valCounter)))        )       ),       inc(valCounter)      )     ),          {**Events**}     for(      valCounter := ATOM_EVENT_FIRST,      valCounter <= ATOM_EVENT_LAST,      Inc(valCounter),      do(       strCode := EventString(s, valCounter),       strEvent := EventName(valCounter),              if(        not(valCaseSensitive),        strCode := Lowercase(strCode)       ),              valNrMatches := SubstrCount(strCode, strSearch),       if(        valNrMatches > 0,        do(         inc(valTotalHits, valNrMatches),         if(          not(valFoundOnAtom),          do(           Trace(Concat([Atom: ], Name(s), [ (], ValueToString(s), [)])),           valFoundOnAtom := 1          )         ),                  Trace(concat(String(valNrMatches, 5, 0), [ times found in event ], strEvent))        )       )      )     )    ),    1   ),      Trace(Concat([--- ], ValueToString(valTotalHits), [ Hits in Total ---])),   DisplayTracer,   Activate(Tracer),   TraceNumbers(1, 1),   s := PopAtomPointer  )], [Search for a string in all functions and events under a specified atom and returns the results in the tracer. e1 = string to search, e2(optional) = 1 or 0 (case sensitive or not), e3(optional) = atom under which the search starts], [SearchStringInCode([ED], 0, main)], 0, [Kernel Functions.atm]);
DefineFunction([Divide], [Math], 2, 2, [Do( /(p(1), p(2)))], [Use this alias instead of / in fieldsmartlist statements.], [Divide(9, 3)], 0, [Kernel Functions.atm]);
DefineFunction([StandardEditStyle], [Various], 0, 0, [Do( SetEditStyle(Name, 100, 250, 50, 0, 600, 10))], [Shortcut to a standard edit style in the edit command.], [StandardEditStyle], 0, [Kernel Functions.atm]);
DefineFunction([StandardDisplay], [Visualization], 1, 4, [Do( RotateCoords(RotationAs), diShape(0, 0, xSize, ySize, 0.25, Colorblack, Colorwhite), diShape(0, 0, xSize, 1, 0.25, Colorblack, Color), If(Scale >= 12,  Do(   If(ParamCount > 3,    diText(0.2, 0.1, p(1), ColorWhite, p(4), 0.5, [Arial],-(xSize, 0.3), 0.85),    diText(0.2, 0.1, p(1), ColorWhite, ColorTransparent, 0.5, [Arial],-(xSize, 0.3), 0.85)   ),   diText(0.2, 1.1, p(2), 0, ColorTransparent, 0.5, [Arial],-(xSize, 0.3), 0.85),   If(ParamCount > 2,    diBmp(-(xSize, 1), 0.2, p(3), scale/30, 25)   )  ) ), RotateCoords(0))], [Draws a standard representation of an atom with header text e1 extra text e2 and icon e3], [StandardDisplay([My Atom])], 0, [Kernel Functions.atm]);
DefineFunction([Draw2DIcon], [Visualization], 1, 4, [Case( p(1), StandardDisplay(p(2), p(3), p(4)), Do(  diShape(0, 0, 1, 1, 0.5, Colorblack, Color),  If(   <(discale, 40),   diText(0.23, 0.15, p(2), Colorblack, Color, 0.5, [Arial]),   diText(0.1, 0.4,name, Colorblack, Color, 0.15, [Arial], 0.85, 0.3)  ) ),  Do(  diShape(0, 0, xSize, ySize, 0, Colorgray, Colorsilver),  diShape(-0.2,-0.2, 1, 1, 0.5, Colorgray, Color),  diOnScale(9, diText(1, 0.1, p(2), Colorblack, Colorsilver, 0.7, [Arial],-(xSize, 1.2), 1)),  diOnScale(20, diText(1, 1.2, p(3), Colorblack, Colorsilver, 0.35, [Arial],-(xSize, 1.2), 0.7)) ),  Do(  diShape(0, 0, xSize, ySize, 0, Color, Color),  diOnScale(9, diText(0.1, 0.1, p(2), Colorblack, Color, 0.7, [Arial],-(xSize, 0.2), 1)) ))], [Draws different 2d representations, depending on e1.], [Draw2DIcon], 0, [Kernel Functions.atm]);
DefineFunction([Di3DFrame], [Visualization], 15, 15, [Do( If(p(10), di3DBox( p(1), p(2), +( p(3), p(6)), p(4), p(5), p(9), p(7), p(8))), If(p(11), di3DBox( p(1), p(2), p(3), p(4), p(5), p(9), p(7), p(8))), If(p(12), di3DBox( p(1), p(2), p(3), p(9), p(5), p(6), p(7), p(8))), If(p(13), di3DBox(+( p(1), p(4)), p(2), p(3), p(9), p(5) + p(9), p(6), p(7), p(8))), If(p(14), di3DBox( p(1), p(2), p(3), p(4), p(9), p(6), p(7), p(8))), If(p(15), di3DBox( p(1),+( p(2), p(5)), p(3), p(4), p(9), p(6), p(7), p(8))))], [Draws a box frame where you can specify which walls to draw and the wall thickness. Parameters are as follows: xpos,ypos,zpos,length,width,height,color,xyrotation about self,xyrotation about atom,wall thickness, rest is 0 or 1 for: top,bottom,front,back,left,rigt.], [di3DFrame(0,0,0,5,3,3,colorblue,0,0,0.2,1,1,0,1,1,1)], 0, [Kernel Functions.atm]);
DefineFunction([ShowSamplemodel], [Various], 1, 8, [Do( Information(pDir(Concat([Work\], p(1) )), False, 0, 125, 300, 445), Set(Viewx, -2), Set(Viewy, -2), Move(2D3D, 300, 135), Size(2D3D, 500, 445), SetLabel([samplemodel], True, Model))], [only used to display sample models with formatted information], [], 0, [Kernel Functions.atm]);
DefineFunction([CopyAtomTableToGui], [Various], 2, 2, [Do( GuiControl(p(2), GUISet([RowCount], nRows( p(1) ) + 1)), GuiControl(p(2), GUISet([ColCount], nCols( p(1) ) + 1)),  LocalValue([columnCount], [rowCount]),  Repeat(nCols( p(1) ) + 1,  Do(   columnCount := Count,   Repeat(nRows( p(1) ) + 1,    Do(     rowCount := Count,     GuiControl( p(2), GUISet([Cells], rowCount - 1, columnCount - 1, Cell(rowCount - 1, columnCount - 1, p(1),2)))    )   )  ) ))], [Checks if atom e1 exists, if not it is loaded.], [], 0, [Kernel Functions.atm]);
DefineFunction([Ted2000Fnc], [Various], 1, 1, [{ --- Old function called a file section --- }Do( ExecFileSection(pdir([kernel.fnc]), p(1)))], [Shortcut to calling an execfilesection in the file kernel.fnc.], [Ted2000Fnc([create atom in model])], 0, [Kernel Functions.atm]);
DefineFunction([ProductSpacing], [Transport], 3, 3, [Do( Case(  p(1),  p(2),  +(p(2),p(3)),  p(3),  Min(p(2),p(3)),  Max(p(2),p(3)) ))], [Used for product spacing on conveyors. e1 is a code, e2 is product length, e3 is extra length. If e1 is: 1:returns e2, 2: returns e2+e3, 3: returns e3, 4:returns min of e2,e3, 5: returns max of e2,e3.], [productspacing(2,xsize(i),1.5)], 0, [Kernel Functions.atm]);
DefineFunction([GetCornerSpeed], [Various], 1, 1, [Do( Case(p(1), [~1|1. Use fixed max. corner speed of ~0.5~ m/s], [if(att([angledifference],c)>~1,~3,~2)|2. Use two different corner speeds: if road angle is between min.angle and ~50~°,choose speed of ~1.5~ m/s, if angle is larger then choose ~0.5~ m/s], [case(  whichistrue(   att([angledifference],c)<=~1,   and(att([angledifference],c)>~1,att([angledifference],c)<=~3),   att([angledifference],c)>~3  ),  ~2,~4,~5)|3. Choose between three speed settings: if angle between min. angle and ~45~°, choose speed ~1.5~ m/s, if angle is larger but smaller than ~90~°, set speed ~1~ m/s, else if larger, set speed ~0.5~ m/s],  [~1|4. By user: enter your own 4DScript expression: ~0.5~ m/s. You can press the small button for the 4DScript editor.] ))], [Returns predefined logics], [GetCornerSpeed(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetSendToTransporter], [Various], 1, 1, [Do( Case(p(1),  [~1|1. Specific channel: always send to channel ~1~],  [min(nroc(out(1,c)),-(+(nroc(out(1,c)),1),indexmatch(nroc(out(1,c)),1,ocready(-(+(nroc(out(1,c)),1),count),out(1,c)))))|2. An open channel (First channel first): search, starting from the first channel, and send to the first open channel found.],  [max(1,indexmatch(nroc(out(1,c)),1,ocready(count,out(1,c))))|3. An open channel (Last channel first): search, starting from the last channel, and send to the first open channel found.],  [indexmax(nroc(out(1,c)),*(ocready(count,out(1,c)),random(100000)))|4. A random open channel: choose a random channel from all the open output channels.],  [bernoulli(~1,~2,~3)|5. By percentage: ~90~% of products go to channel ~1~, the remaining percentage go to channel ~2~],  [if(comparetext(name(rank(~1,c)),[~2]),~3,~4)|6. By atom name: if the atom name of the ~1~st atom in the queue matches ~AtomName~ then send to channel ~1~ else ~2~.],  [if(ddb([~1],rank(~2,c))<=0,~3,min(ddb([~1],rank(~2,c)),nroc(out(1,c))))|7. By label value (direct): the channel number is written directly on the label named ~LabelName~ of the ~1~st atom in the queue. If the label value is 0 then send to channel ~1~.],  [if(~3(ddb([~1],rank(~2,c)),~4),~5,~6)|8. By label value (conditional): if the value on the label named ~LabelName~ of the ~1~st atom in the queue is ~<~ the value ~1~ then send to channel ~1~ else ~2~.],  [if(comparetext(ddb([~1],rank(~2,c)),[~3]),~4,~5)|9. By label text: if the text on the label named ~LabelName~ of the ~1~st atom in the queue matches ~text~ then send to channel ~1~ else ~2~.],  [if(~2(~1,~3),~4,~5)|10. Conditional statement: If ~1~ is ~>~ than ~0~ then send to channel ~1~ else send to channel ~2~],  [if(=(icon(rank(~1,c)),iconbyname([~2])),~3,~4)|11. By icon name: if the icon name of the ~1~st atom in the queue matches ~IconName~ then send to channel ~1~ else ~2~.],  [if(~2(icon(rank(~1,c)),~3),~4,~5)|12. By icon number: if the icon number of the ~1~st atom in the queue is ~=~ the value ~1~ then send to channel ~1~ else ~2~.],  [indexmatchrank(nroc(out(1,c)),atomexists(out(count,out(1,c))),true,1 + mod(output(out(1,c)),countmatch(nroc(out(1,c)),atomexists(out(count,out(1,c))),true)))|13. Round robin: all outputchannels are used in rotation.  If channel is closed, then wait till open.],  [indexmin(nroc(out(1,c)),content(out(count,out(1,c))))|14: Lowest queue: Send to the channel connected to the atom with the lowest queue.],  [indexmax(nroc(out(1,c)),content(out(count,out(1,c))))|15: Largest queue: Send to the channel connected to the atom with the largest queue.],  [~3(~1,~2)|16: Lookup table: Send to the channel specified in row ~1~ column ~2~ of global table named ~table1~.],  [do(inc(ddb([t_rr],c)),if(ddb([t_rr],c)=nroc(c)+1,sddb([t_rr],1,c)),loopuntil(ocready(ddb([t_rr],c),out(1,c)),do(inc(ddb([t_rr],c)),if(ddb([t_rr],c)=nroc(c)+1,sddb([t_rr],1,c))),nroc(c)),ddb([t_rr],c))|17. Round robin if available: all outputchannels are used in rotation if channel is available.  If channel is closed, then next available channel is chosen.],  [indexmatch(nroc(out(1,c)),1,or(content(out(count,out(1,c)))=0,icon(first(c))=icon(last(out(count,out(1,c))))))|18. Matching icon number or empty: Sends to a queue containing products of same icon. If no icons match, then sends to first empty queue starting with last output channel.],  [indexmin(nroc(out(1,c)),content(out(count,out(1,c)))+content(out(1,out(count,out(1,c)))))|19. Lowest queue of next two atoms: Sends to the output channel connected to the lowest queue, where lowest queue takes into account the next TWO atoms.],  [~1|20. By user: enter your own 4DScript expression resulting in a value between 1 and the number of channels: ~1~. You can press the small button for the 4DScript editor.],  [c.NextOutputChannel|21. Defined by warehouse: The Pick Order Generator has ordered the warehouse where to place the product.] ))], [Returns predefined logics], [GetSendToTransporter(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetSendTo], [Various], 1, 1, [Do(
 Case(p(1),
  [~1|1. Specific channel: always send to channel ~1~],
  
  [Min(NrOC(c), NrOC(c) + 1 - IndexMatch(NrOC(c), 1, OCReady(NrOC(c) + 1 - Count, c)))|2. An open channel (First channel first): search, starting from the first channel, and send to the first open channel found.],
  
  [Max(1,IndexMatch(NrOC(c),1,OCReady(Count,c)))|3. An open channel (Last channel first): search, starting from the last channel, and send to the first open channel found.],
  
  [IndexMax(NrOC(c), OCReady(Count,c)*Random(100000))|4. A random open channel: choose a random channel from all the open output channels.],

  [Bernoulli(~1,~2,~3)|5. By percentage: ~90~% of products go to channel ~1~, the remaining percentage go to channel ~2~],

  [if(CompareText(Name(Rank(1,c)),[~1]),~2,~3)|6. By atom name: if the atom name matches ~AtomName~ then send to channel ~1~ else ~2~.],

  [Label([~1], first(c))|7. By label value (direct): Use the value stored in the Label named ~LabelName~ and send to the corresponding channel.],
 
  [if(Label([~1], first(c)) ~2 ~3, ~4, ~5)|8. By label value (conditional): if the value stored in the label named ~LabelName~ is ~<~ than ~1~ then send to channel ~1~ else ~2~.],

  [if(CompareText(Label([~1], First(c)), [~2]),~3,~4)|9. By label text: if the text on the label named ~LabelName~ matches ~text~ then send to channel ~1~ else ~2~.],

  [if(~1 ~2 ~3, ~4, ~5)|10. Conditional statement: If "~1~" is ~>~ than ~0~ then send to channel ~1~ else send to channel ~2~],

  [if(icon(rank(1,c)) = IconByName([~1]), ~2, ~3)|11. By icon name: if the icon name matches ~IconName~ then send to channel ~1~ else ~2~.],

  [if(icon(rank(1,c)) ~1 ~2, ~3, ~4)|12. By icon number: if the icon number is ~=~ the value ~1~ then send to channel ~1~ else ~2~.],

  [IndexMatchRank(
 NrOC(c), 
 AtomExists(out(Count,c)), 
 True, 
 mod(Output(c), CountMatch(NrOC(c), AtomExists(out(count,c)),True)) + 1
)|13. Round robin: all outputchannels are used in rotation.  If channel is closed, then wait till open.],


  [IndexMin(NrOC(c), if(OCReady(Count,c), Content(out(Count,c)),1e50))|14: Smallest queue: Send to the channel connected to the atom with the smallest queue],

  [IndexMax(NrOC(c), Content(out(Count,c)))|15: Largest queue: Send to the channel connected to the atom with the largest queue],

  [~3(~1,~2)|16: Lookup table: Send to the channel specified in row ~1~ column ~2~ of global table named ~table1~],

  [do(
 inc(Label([t-rr],c)),
 if(Label([t-rr],c) > NrOC(c), Label([t-rr],c) := 1),
 LoopUntil(
  OCReady(Label([t-rr],c),c),
  do(
   inc(Label([t-rr],c)),
   if(Label([t-rr],c) = NrOC(c) + 1, Label([t-rr],c) := 1)
  ),
  NrOC(c)
 ),
 Label([t-rr],c)
)|17. Round robin if available: all outputchannels are used in rotation if channel is available.  If channel is closed, then next available channel is chosen.],

  [IndexMatch(NrOC(c), 1, or(Content(out(Count,c)) = 0, icon(First(c)) = icon(Last(out(Count,c)))))|18. Matching icon number or empty: Sends to a queue containing products of same icon. If no icons match, then sends to first empty queue starting with last output channel.],

  [IndexMin(NrOC(c), Content(out(Count,c)) + Content(out(1,out(Count,c))))|19. Lowest queue of next two atoms: Sends to the output channel connected to the lowest queue, where lowest queue takes into account the next TWO atoms],

  [~1|20. By user: enter your own 4DScript expression resulting in a value between 1 and the number of channels: ~1~. You can press the small button for the 4DScript editor.],

  [dUniform(1,NrOC(c))|21. Random channel: randomly choose a channel. If the channel is open then send to it, otherwise choose again when any channel opens.]
 )
)
 
], [Returns predefined logics], [GetSendTo(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetSendToCrane], [Various], 1, 1, [Do(
 Case(p(1),
  [~1|1. Specific channel: always send to channel ~1~/],
  [min(nroc(c),-(+(nroc(c),1),indexmatch(nroc(c),1,icopen(ocicno(-(+(nroc(c),1),count),c),out(-(+(nroc(c),1),count),c)))))|2. An open channel (First channel first): search, starting from the first channel, and send to the first open channel found./],
  [max(1,indexmatch(nroc(c),1,icopen(ocicno(count,c),out(count,c))))|3. An open channel (Last channel first): search, starting from the last channel, and send to the first open channel found./],
  [duniform(1,nroc(c))|4. Random channel: randomly choose a channel. If the channel is open then send to it, otherwise choose again when any channel opens./],
  [bernoulli(~1,~2,~3)|5. By percentage: ~90~% of products go to channel ~1~, the remaining percentage go to channel ~2~/],
  [if(comparetext(name(rank(~1,c)),[~2]),~3,~4)|6. By atom name: if the atom name of the ~1~st atom in the queue matches ~AtomName~ then send to channel ~1~ else ~2~./],
  [max(min(ddb([~1],rank(~2,c)),nroc(c)),~3)|7. By label value (direct): the channel number is written directly on the label named ~LabelName~ of the ~1~st atom in the queue. If the label value is 0 then send to channel ~1~./],
  [if(~3(ddb([~1],rank(~2,c)),~4),~5,~6)|8. By label value (conditional): if the value on the label named ~LabelName~ of the ~1~st atom in the queue is ~<~ the value ~1~ then send to channel ~1~ else ~2~./],
  [if(comparetext(ddb([~1],rank(~2,c)),[~3]),~4,~5)|9. By label text: if the text on the label named ~LabelName~ of the ~1~st atom in the queue matches ~text~ then send to channel ~1~ else ~2~./],
  [if(~2(~1,~3),~4,~5)|10. Conditional statement: If ~1~ is ~>~ than ~0~ then send to channel ~1~ else send to channel ~2~/],
  [if(=(icon(rank(~1,c)),iconbyname([~2])),~3,~4)|11. By icon name: if the icon name of the ~1~st atom in the queue matches ~IconName~ then send to channel ~1~ else ~2~./],
  [if(~2(icon(rank(~1,c)),~3),~4,~5)|12. By icon number: if the icon number of the ~1~st atom in the queue is ~=~ the value ~1~ then send to channel ~1~ else ~2~./],
  [+(mod(output(c),nroc(c)),1)|13. Round robin: all outputchannels are used in rotation.  If channel is closed, then wait till open./],
  [indexmin(nroc(c),content(out(count,c)))|14: Lowest queue: Send to the channel connected to the atom with the lowest queue/],
  [indexmax(nroc(c),content(out(count,c)))|15: Largest queue: Send to the channel connected to the atom with the largest queue/],
  [~3(~1,~2)|16: By lookup table: Send to the channel specified in row ~1~ column ~2~ of global table named ~table1~/],
  [~1|17. By user: enter your own 4DScript expression resulting in a value between 1 and the number of channels: ~1~. You can press the small button for the 4DScript editor]
 )
)
], [Select the next destination.], [GetSendToCrane(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetInputStrategy], [Various], 1, 1, [Do( Case(p(1),  [openallic(c)|1. Any inputchannel],  [if(=(sum(nric(c),if(atomexists(in(count,c)),*(ocopen(icocno(count,c),in(count,c)),content(in(count,c))),0)),0),openallic(c),openic(indexmax(nric(c),if(atomexists(in(count,c)),*(ocopen(icocno(count,c),in(count,c)),content(in(count,c))),0)),c))|2. Largest queue: Accept product from the atom with the largest queue (if all queues are empty then open all channels and wait)],  [if(=(sum(nric(c),if(atomexists(in(count,c)),*(ocopen(icocno(count,c),in(count,c)),content(in(count,c))),0)),0),openallic(c),openic(indexmax(nric(c),if(atomexists(in(count,c)),*(ocopen(icocno(count,c),in(count,c)),if(>(content(in(count,c)),0),-(time,entrytime(first(in(count,c)))),0)),0)),c))|3. Longest waiting: Accept product from the atom whose first product entered earliest (if all queues are empty then open all channels and wait)],  [openic(+(mod(input(c),nric(c)),1),c)|4. Round robin],  [openic(~1,c)|5. Channel ~1~] ))], [Returns predefined logics], [GetInputStrategy(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetSetupTime], [Various], 1, 1, [Do( Case(p(1),  [0|1. No setup time],  [~1|2. Fixed setup time: every product has a setup time of ~10~],  [if(mod(output(c),~1),~2,0)|3. Fixed intervals: every ~10~ th product has a setup time of ~10~],  [if(=(ddb([~1],first(c)),~2),~3,~4)|4. Depending on label: if the product label value named ~Labelname~ equals ~1~ then the setup time is ~10~ else the setup time is ~0~],  [if(<>(t-Getsetupcode(label([~1],first(c)),0),ddb([t-oldsetupcode],c)),~2,0)|5. Cur-Prev Label: if the value of the label named ~LabelName~ of the current and previous atom are different, the setuptime is ~10~],  [if(<>(t-Getsetupcode(color(first(c)),0),ddb([t-oldsetupcode],c)),~1,0)|6. Cur-Prev Color: if the color of the current and previous atom are different, the setuptime is ~10~],  [do(t-Getsetupcode(name(first(c)),0),if(comparetext(ddb([t-setupcode],c),ddb([t-oldsetupcode],c)),0,~1))|7. Cur-Prev Name: if the name of the current and previous atom are different, the setuptime is ~10~],  [if(<>(t-Getsetupcode(icon(first(c)),0),ddb([t-oldsetupcode],c)),~1,0)|8. Cur-Prev Icon: if the icon of the current and previous atom are different, the setuptime is ~10~],  [if(<>(t-Getsetupcode(*(xsize(first(c)),ysize(first(c)),zsize(first(c))),0),ddb([t-oldsetupcode],c)),~1,0)|9. Cur-Prev Volume: if the volume (LxWxH) of the current and previous atom are different, the setuptime is ~10~],  [do(t-Getsetupcode(label([~2],first(c)),~3),~1(ddb([t-oldsetupcode],c),ddb([t-setupcode],c)))|10. Global Table Alias: the setuptime is found in table ~TableName~. The row-column indicator is stored in the label named ~LabelName~. The value is in row(previous product),column(current product). The startvalue of the indicator is ~1~],  [do(t-Getsetupcode(label([~2],first(c)),~3),cell(ddb([t-oldsetupcode],c),ddb([t-setupcode],c),in(~1,c)))|11. Setup Table: the setuptime is found in the setup table connected to inputchannel ~2~. The row-column indicator is stored in the label named ~LabelName~. The value is in row(previous product),column(current product). The startvalue of the indicator is ~1~] ))], [Returns predefined logics], [GetSetupTime(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetDistributionOptions], [Various], 0, 0, [Do(
 Concat(
  Concat(Char(1),[objectstart],Char(1),[code:],[NegExp(10)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Erlang(10, 2)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[LogNormal(10, 2)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Bernoulli(50, 5, 15)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Max(0, Normal(10, 1))],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Beta(10, 1, 1)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Gamma(10, 2)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Max(0, Logistic(10, 1))],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[LogNormal(10, 1)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Uniform(5, 15)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Triangular(10, 5, 15)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Weibull(10, 2)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Label([ALabel], First(c))],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Label([ALabel], c)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[If(? = ?, ?, ?)],Char(1),[objectend])
 )
)
], [Returns predefined logics], [GetDistributionOptions], 0, [Kernel Functions.atm]);
DefineFunction([GetMCBF], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[Poisson(5)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[NegBinomial(3, 70)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[Bernoulli(50, 5, 15)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[BiNomial(4, 20)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[DUniform(5, 15)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[if(=(?,?),?,?)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[Label([ALabel], First(c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[label([ALabel],c)],Char(1),[objectend]) ))], [Returns predefined logics], [GetMCBF], 0, [Kernel Functions.atm]);
DefineFunction([GetTriggerEnterExit], [Various], 0, 0, [Do(
 Concat(
  Concat(Char(1),[objectstart],Char(1),[code:],[0], Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Label([?], i) := ?],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Name(i) := [?]],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Icon(i) := ?],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Icon(i) := IconByName([?])],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[Color(i) := ColorYellow],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[SetSize(?,?,?,i)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[SetLoc(?,?,?,i)],Char(1),[objectend]), 
  Concat(Char(1),[objectstart],Char(1),[code:],[CallOperators(AtomByName([Team],Model),1)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[FreeOperators(AtomByName([Team],Model),i)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[if(? = ?, ?, ?)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[if(Label([?], i) = ?, ?, ?)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[if(CompareText(Name(i), [?]), ?, ?)],Char(1),[objectend])
 )
)

], [Returns predefined logics], [GetTriggerEnterExit], 0, [Kernel Functions.atm]);
DefineFunction([GetNumberOfProducts], [Various], 1, 1, [Do( Case(p(1),  [-1|1. Unlimited],  [~1|2. Generate maximum ~100~ products] ))], [Returns predefined logics], [GetNumberOfProducts(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetCreationTrigger], [Various], 1, 1, [Do( Case(p(1),  [Label([~1], i) := ~2|1. Assign label: products are assigned a label named ~LabelName~ with a value of ~1~],  [Name(i) := Concat(Name(i),[-],String(Output(c) + 1))|2. Auto Name: a counter is added to the end of each product's name],  [Icon(i) := dUniform(~1,~2)|3. Random icons: products are assigned a random icon number between ~2~ and ~6~],  [SetSize(cm(~1),cm(~2),cm(~3),i)|4. Set Size: product dimensions are set to: X=~50~cm, Y=~40~cm, Z=~30~cm],  [SetSize(cm(dUniform(~1,~2)),cm(duniform(~3,~4)),cm(duniform(~5,~6)),cs)|5. Random Size: product dimensions are randomly set within the following ranges: X=~50~to~100~cm, Y=~50~to~100~cm, Z=~50~to~100~cm],  [Color(i) := ~1|6. Set Color: products are set to the ~colorpurple~],  [Color(i) := dUniform(1,10000000)|7. Random color: products are assigned a random color],  [do( SetSize(cm(dUniform(~1,~2)),cm(dUniform(~3,~4)),cm(duniform(~5,~6)),i),  Color(i) := dUniform(1,1000000))|8. Random Size and Color: products are assigned a random color and its dimensions are randomly set within the following ranges: X=~50~to~100~cm, Y=~50~to~100~cm, Z=~50~to~100~cm],  [do( SetSetting(sa2DDraw,0,i), SetSetting(saIcon,0,i), SetSetting(sa2doutline,1,i))|9. Display the products as simple outlines, not icons],  [0|10. Do Nothing] ))], [Returns predefined logics], [GetCreationTrigger(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetQueueDiscipline], [Various], 1, 1, [Do( Case(p(1),  [content(c)|1. Fifo (First In First Out)],  [1|2. Lifo (Last In First Out)],  [duniform(1,content(c))|3. Random],  [t-findqueuepos([~1],2)|4. Sort by Label Ascending: The atoms with the lowest value of the label named ~LabelName~ are put in front],  [t-findqueuepos([~1],1)|5. Sort by Label Descending: The atoms with the highest value of the label named ~LabelName~ are put in front],  [~1|6. User defined: put the incoming product at location ~1~] ))], [Returns predefined logics], [GetQueueDiscipline(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetDefaultSpeed], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[mm(1000)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[cm(100)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[inch(36)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[feet(3)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[yard(1)],Char(1),[objectend]) ))], [Returns predefined logics], [GetDefaultSpeed], 0, [Kernel Functions.atm]);
DefineFunction([GetResponse], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[msg(message)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[execstring(message)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[do(createatom(atombyname([T050-Product],library),c))],Char(1),[objectend]) ))], [Returns predefined logics], [GetResponse], 0, [Kernel Functions.atm]);
DefineFunction([GetPFM], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[label([?],in(1,cs))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[input(in(1,cs))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[output(in(1,cs))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[content(in(1,cs))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgcontent(in(1,cs))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maxcontent(in(1,cs),0,time)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgstay(in(1,cs))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[timeforstatus(in(1,cs),3,0,time)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[sum(nric,content(in(count,cs)))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[mean(nric,content(in(count,cs)))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[minimum(nric,content(in(count,cs)))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maximum(nric,content(in(count,cs)))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[{user defined}],Char(1),[objectend]) ))], [Returns predefined logics], [GetPFM], 0, [Kernel Functions.atm]);
DefineFunction([GetVariable], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[setlabel([?],att([varvalue],c),in(1,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[setatt([cycletime],att([varvalue],c),in(1,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[setatt([capacity],att([varvalue],c),in(1,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[setatt([speed],att([varvalue],c),in(1,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[setatt([loadtime],att([varvalue],c),in(1,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[setatt([unloadtime],att([varvalue],c),in(1,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[setnumberops(in(1,c),att([varvalue],c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[{user defined}],Char(1),[objectend]) ))], [Returns predefined logics], [GetVariable], 0, [Kernel Functions.atm]);
DefineFunction([GetObjective], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[att([totcostprofit],in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[label([?],in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[input(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[output(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[content(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgcontent(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maxcontent(in(1,c),0,time)/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgstay(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[timeforstatus(in(1,c),3,0,time)/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[minage(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maxage(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgage(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[sum(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[mean(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[minimum(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maximum(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[{user defined}],Char(1),[objectend]) ))], [Returns predefined logics], [GetObjective], 0, [Kernel Functions.atm]);
DefineFunction([GetRequirement], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[att([totcostprofit],in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[label([?],in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[input(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[output(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[content(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgcontent(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maxcontent(in(1,c),0,time)/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgstay(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[timeforstatus(in(1,c),3,0,time)/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[minage(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maxage(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[avgage(in(1,c))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[sum(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[mean(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[minimum(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[maximum(nric(c),content(in(count,c)))/],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[{user defined}],Char(1),[objectend]) ))], [Returns predefined logics], [GetRequirement], 0, [Kernel Functions.atm]);
DefineFunction([GetUserAction], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[closeoutput(out(?,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[closeinput(out(?,c))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[do(closeoutput(out(?,c)),closeinput(out(?,c)))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[repeat(nroc(c),if(atomexists(out(count,c)),closeoutput(out(count,c))))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[repeat(nroc(c),if(atomexists(out(count,c)),closeinput(out(count,c)))],Char(1),[objectend]) ))], [Returns predefined logics], [GetUserAction], 0, [Kernel Functions.atm]);
DefineFunction([GetAtomReference], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[out(1,c)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[atombyname([Source1],model)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[c],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[{user defined}],Char(1),[objectend]) ))], [Returns predefined logics], [GetAtomReference], 0, [Kernel Functions.atm]);
DefineFunction([GetUnpackQuantity], [Various], 0, 0, [Do(
 Concat(
  Concat(Char(1),[objectstart],Char(1),[code:],[content(first(c))],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[duniform(1,10)],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[label([?],first(c))],Char(1),[objectend]),
  Concat(Char(1),[objectstart],Char(1),[code:],[if(? = ?,?,?)],Char(1),[objectend])
 )
)
], [Returns predefined logics], [GetUnpackQuantity], 0, [Kernel Functions.atm]);
DefineFunction([GetPut], [Various], 0, 1, [Case( p(1) + 1, {--Row--} Do(  Concat(   Concat(Char(1),[objectstart],Char(1),[code:],[duniform(1,nRows(c))],Char(1),[objectend]),   Concat(Char(1),[objectstart],Char(1),[code:],[label([?],i)],Char(1),[objectend]),   Concat(Char(1),[objectstart],Char(1),[code:],[if(=(?,?),?,?)],Char(1),[objectend]),   Concat(Char(1),[objectstart],Char(1),[code:],[cell(?,?,?)],Char(1),[objectend])  ) ), {--Column--} Do(  Concat(   Concat(Char(1),[objectstart],Char(1),[code:],[duniform(1,nCols(c))],Char(1),[objectend]),   Concat(Char(1),[objectstart],Char(1),[code:],[label([?],i)],Char(1),[objectend]),   Concat(Char(1),[objectstart],Char(1),[code:],[if(=(?,?),?,?)],Char(1),[objectend]),   Concat(Char(1),[objectstart],Char(1),[code:],[cell(?,?,?)],Char(1),[objectend])  ) ))], [Returns predefined logics], [GetPut], 0, [Kernel Functions.atm]);
DefineFunction([GetOffset], [Various], 1, 1, [Do( Case(p(1),  [~1|1. Fixed --> always apply an offset of ~0~ meter.],  [label([~1],i)|2. Atom label --> the offset is found on label ~LabelName~ of the atom to be picked or placed.],  [yabsloc(c,model)-yabsloc(in(2,c),model)|3. Horizontal line --> the transporter travels in a horizontal line. ~Only use this option to define the Y offsets!~],  [xabsloc(c,model)-xabsloc(in(2,c),model)|4. Vertical line --> the transporter in a vertical line. ~Only use this option to define the X offsets!~],  [+(~1(in(2,c)),~2)|5. Destination size --> apply an offset equal to the ~xsize~ of the destination plus ~0~ meter.],  [label([~1],in(2,c))|6. Destination label --> the offset is found on label ~LabelName~ of the destination.],  [if(comparetext(name(in(2,c)),[~1]),~2,~3)|7. Destination name --> if the name of the destination equals ~AtomName~ then ~1~ else ~0~ meter.],  [~1(label([~2],i),label([~3],i))|8. Lookup table --> look for the offset in table ~TableName~. The row is set by label ~LabelName~ and the column by label ~LabelName~ of the atom to be picked/placed.] ))], [Returns predefined logics], [GetOffset(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetOperatorRule], [Various], 1, 1, [Do( Case(p(1),  [~1|1. Specific row --> Always use the settings of row ~1~ in the operator lookup table.],  [indexmatch(nrows(c),cell(count,1,c),name(i))|2. By atom name --> Use the atom name to lookup the operator data.],  [indexmatch(nrows(c),cell(count,1,c),ddb([~1],i))|3. By label text --> Use the text on label ~LabelName~ to lookup the operator data.],  [ddb([~1],i)|4. By label value --> The value of label ~LabelName~ indicates the correct row in the lookup table.] ))], [Returns predefined logics], [GetOperatorRule(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetAtomSelection], [Various], 1, 1, [Do( Case(p(1),  [string(label([~1],i))|1. Value or string of ~Labelname~],  [string(time,0,1)|2. Entry time],  [string(age(i),0,1)|3. Throughput (a) -> Throughput from start],  [string(time-label([~1],i),0,1)|4. Throughput (b) -> Throughput from time defined in ~Labelname~],  [string(input(c)-att(20,c))|5. Number of products that entered during analysis],  [name(i)|6. Name of product],  [[~1]|7. Text by user: ~true~],  [string(~1)|8. Expression by user: ~true~] ))], [Returns predefined logics], [GetAtomSelection(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetAnaysisTime], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[time {current value}],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[60 {seconds}],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[mins(60) {minutes}],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[hr(8) {hours}],Char(1),[objectend]) ))], [Returns predefined logics], [GetAnaysisTime], 0, [Kernel Functions.atm]);
DefineFunction([GetGraphValue], [Various], 1, 1, [Do( Case(p(1),  [~1|1. When x equals 'gp', y equals ~gp~],  [if(gp <= NrIC(c), Label([~1], in(gp,c)), 0)|2. The value of the label named ~LabelName~ of the atoms connected to the inputchannels of the graph],  [if(gp <= NrIC(c), Age(in(gp,c)), 0)|3. The ages of the atoms connected to the inputchannels of the graph],  [if(gp <= NrIC(c), Content(in(gp,c)), 0)|4. The contents of the atoms connected to the inputchannels of the graph],  [if(and(gs <= NrIC(c), gp <= Content(in(gs,c))), Label([~1],Rank(gp,in(gs,c)),0)|5. Each inputchannel represents a series. The values are the labels named ~mylabel~ of the atoms in the atoms connected to the graph],  [if(and(gs <= NrIC(c), gp <= Content(in(gs,c))), Age(Rank(gp,in(gs,c))),0)|6. Each inputchannel represents a series. The values are the ages of the atoms in the atoms connected to the graph] ))], [Returns predefined logics], [GetGraphValue(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetGraphLabel], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[String(gp)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[case(gp,[First],[Second],[Third])],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[Concat([No], String(gp))],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[if(gp <= NrIC(c), Name(in(gp,c)), [?])],Char(1),[objectend]) ))], [Returns predefined logics], [GetGraphLabel], 0, [Kernel Functions.atm]);
DefineFunction([GetMeasuringUnit], [Various], 1, 1, [Do( Case(p(1),  [1|1. Amount of products],  [ddb([~1],cs)|2. By Label Value : The value of the unit is on ~Labelname~],  [xsize(cs)|3. x-size of products],  [ysize(cs)|4. y-size of products],  [~1|5. By user: enter your own 4DScript expression: ~1~. Refer to product with "cs"] ))], [Returns predefined logics], [GetMeasuringUnit(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetRepeatTime], [Various], 1, 1, [Do( Case(p(1),  [0|1. No repeat],  [-1|2. Continues repeat],  [hr(~1)|3. The repeat time is ~8~ hours],  [~1|4. The repeat time is ~1000~ seconds] ))], [Returns predefined logics], [GetRepeatTime(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetAtomSelectionRule], [Various], 1, 1, [Do( Case(p(1),  [false|1. do not transform],  [true|2. transform all atoms],  [comparetext(name(i),[~1])|3. by atom name --> transform the atom if its name equals ~AtomName~.],  [comparetext(label([~1],i),[~2])|4. by label text --> transform the atom if its label ~LabelName~ equals the text ~LabelText~.],  [~2(label([~1],i),~3)|5. by label value --> transform the atom if its label ~LabelName~ is ~=~ the value ~1~.],  [=(icon(i),iconbyname([~1]))|6. by icon --> transform the atom if its icon equals the icon by name ~IconName~.],  [bernoulli(~1,true,false)|7. by percentage --> at random ~50~% of the atoms will be transformed.],  [=(mod(input(c),~1),0)|8. by cycle --> every ~10~-th atom will be transformed.],  [~1|9. by user logic --> if ~true~ is true the atom will be transformed.] ))], [Returns predefined logics], [GetAtomSelectionRule(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetRowSelectionRule], [Various], 1, 1, [Do( Case(p(1),  [setatt(7,~1,c)|1. specific row --> always apply the transformations that have been defined at row ~1~.]  [setatt(7,indexmatch(nrows(c),cell(count,1,c,2),name(i)),c)|2. atom name --> transformations will be applied where the atom name in the row matches the atom name of the passing atom.],  [setatt(7,indexmatch(nrows(c),cell(count,1,c,2),ddb([~1],i)),c)|3. label text --> transformations will be applied where the text of label ~LabelName~ matches the label text of the passing atom.],  [setatt(7,indexmatch(nrows(c),cell(count,1,c,1),ddb([~1],i)),c)|4. label value --> transformations will be applied where the value of the label ~LabelName~ matches the label value of the passing atom.],  [setatt(7,duniform(1,nrows(c)),c)|5. randomly --> randomly select a row in the table and apply these changes to the passing atom.],  [setatt(7,round(~1),c)|6. empirical distribution --> the row number in the transformation table is defined by the empirical distribution ~EmpiricalDistributionName~ (values are rounded).] ))], [Returns predefined logics], [Enter Syntax Example], 0, [Matthijs Jongboer]);
DefineFunction([GetLabel], [Various], 1, 1, [Do( Case(p(1),  [setlabel([~1],[~2],i)|1. Text label --> set the label ~LabelName~ equal to ~LabelText~.],  [setlabel([~1],~2,i)|2. Value label --> set the label ~LabelName~ equal to ~1~.] ))], [Returns predefined logics], [GetLabel(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetSort], [Various], 1, 1, [Do( Case(p(1),  [[no sort required]|1. FIFO --> first in first out.],  [t-sortby(>(entrytime(next(cs)),entrytime(cs)),c)|2. LIFO --> last in first out.],  [t-sortby(<(content(in(1,next(cs))),content(in(1,cs))),c)|3. Content minimum --> atoms in the container with the smallest content are dispatched first.],  [t-sortby(>(content(in(1,next(cs))),content(in(1,cs))),c)|4. Content maximum --> atoms in the container with the largest content are dispatched first.],  [t-sortby(<(ddb([t-ic],next(cs)),ddb([t-ic],cs)),c)|5. IC minimum --> lowest input channel of dispatcher first.],  [t-sortby(>(ddb([t-ic],next(cs)),ddb([t-ic],cs)),c)|6. IC Maximum --> highest input channel of dispatcher first.],  [t-sortby(<(ddb([~1],in(3,next(cs))),ddb([~1],in(3,cs))),c)|7. Label minimum (atom) --> the atom with the lowest value on label ~LabelName~ is dispatched first.],  [t-sortby(>(ddb([~1],in(3,next(cs))),ddb([~1],in(3,cs))),c)|8. Label maximum (atom) --> the atom with the highest value on label ~LabelName~ is dispatched first.],  [t-sortby(<(ddb([~1],in(1,next(cs))),ddb([~1],in(1,cs))),c)|9. Label minimum (container) --> atoms in the container with the lowest value on label ~LabelName~ are dispatched first.],  [t-sortby(>(ddb([~1],in(1,next(cs))),ddb([~1],in(1,cs))),c)|10. Label maximum (container) --> atoms in the container with the highest value on label ~LabelName~ are dispatched first.] ))], [Returns predefined logics], [GetSort(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetDispatchTo], [Various], 1, 1, [Do( Case(p(1),  [if(loadpermission(out(~1,c),in(3,cs)),~1,0)|1. Specific channel --> always send to channel ~1~/],  [dispatch_ftf|2. A free transporter (FTF) --> look for a free transporter. Check the First Transporter connected to the dispatcher First./],  [indexmatch(nroc(c),true,*(icready(1,out(count,c)),loadpermission(out(count,c),in(3,cs))))|3. A free transporter (LTF) --> look for a free transporter. Check the Last Transporter connected to the dispatcher First./],  [label([~1],in(3,cs))|4. By label (channel) --> The channel number to dispatch to is written on label ~LabelName~ of the atom to be picked./],  [if(label([~1],in(3,cs))~2,~3,~4)|5. By label (value) --> If the value on label ~LabelName~ of the atom to be picked ~=1~ then dispatch to ~1~ else to ~2~./],  [if(comparetext(label([~1],in(3,cs)),~2),~3,~4)|6. By label (text) --> If the text on label ~LabelName~ of the atom to be picked equals ~LabelText~ then dispatch to ~1~ else to ~2~./],  [duniform(1,nroc(c))|7. Random transporter --> randomly choose a transporter, no matter if it's free or not. Choose once again when any transporter is freed./],  [dispatch_maxload|8. Maximum load --> dispatch to the transporter with the highest content./],  [dispatch_minload|9. Minimum load --> dispatch to the transporter with the lowest content.] ))], [Returns predefined logics], [GetDispatchTo(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetMovement], [Various], 1, 1, [Do( Case(p(1),  [do(setatt(26,7,c),setatt(33,7,c),repeat(6,setatt(+(count,26),1,c)),repeat(6,setatt(+(count,33),1,c)))|1. All directions toGether/],  [do(setatt(26,2,c),setatt(27,6,c),setatt(28,3,c),setatt(33,2,c),setatt(34,6,c),setatt(35,3,c),repeat(4,setatt(+(count,28),1,c)),repeat(4,setatt(+(count,35),1,c)))|2. x,y toGether with transportheight/],  [do(setatt(26,4,c),setatt(27,5,c),setatt(28,3,c),setatt(33,4,c),setatt(34,5,c),setatt(35,3,c),repeat(4,setatt(+(count,28),1,c)),repeat(4,setatt(+(count,35),1,c)))|3. in sequence: x,y,z/],  [do(setatt(26,2,c),setatt(27,4,c),setatt(28,5,c),setatt(29,3,c),setatt(33,2,c),setatt(34,4,c),setatt(35,5,c),setatt(36,3,c),repeat(3,setatt(+(count,29),1,c)),repeat(3,setatt(+(count,36),1,c)))|4. in sequence x,y with transportheight] ))], [Returns predefined logics], [GetMovement(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetMovement2], [Various], 1, 1, [Do( Case(p(1),  [1|Nothing],  [2|Up],  [3|Down],  [4|X Direction],  [5|Y Direction],  [6|XY Direction],  [7|XYZ Direction],  [8|Fixed X Value],  [9|Fixed Y Value] ))], [Returns predefined logics], [GetMovement2(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetProductStatistics], [Various], 1, 1, [Do( Case(p(1),  [Label([~1],i)|1. Value or string of ~Labelname~],  [Time|2. Entry time],  [Age(i)|3. Lead time from start],  [Time - Label([~1],i)|4. Lead time from time defined in ~Labelname~],  [if(time > att(18,c), (input(c)-att(20,c))/(time-att(18,c)))|5. Throughput],  [Input(c) - att(20,c)|6. Number of products that entered during analysis],  [Name(i)|7. Name of product],  [~1|8. Expression by user: ~true~] ))], [Returns predefined logics for Data Recorder atom.], [GetProductStatistics(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetProductCriteria], [Various], 1, 1, [Do( Case(p(1),  [1|1. measure for all atoms/],  [comparetext(name(i),[~1])|2. by atom name --> measure variables of the atom if its name equals ~AtomName~./],  [comparetext(ddb([~1],i),[~2])|3. by label text --> measure variables of the atom if its label ~LabelName~ equals the text ~LabelText~./],  [~2(ddb([~1],i),~3)|4. by label value --> measure variables of the atom if its label ~LabelName~ is ~=~ the value ~1~./],  [=(icon(i),iconbyname([~1]))|5. by icon --> measure variables of the atom if its icon equals the icon by name ~IconName~./],  [~1|6. by user logic --> if ~true~ is true the variables of the atom will be measured.] ))], [Returns predefined logics], [GetProductCriteria(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetObjectivesOrRequirements], [Various], 1, 1, [Do( Case(p(1),  [1|1. measure for all atoms/],  [comparetext(name(i),[~1])|2. by atom name --> measure variables of the atom if its name equals ~AtomName~./],  [comparetext(ddb([~1],i),[~2])|3. by label text --> measure variables of the atom if its label ~LabelName~ equals the text ~LabelText~./],  [~2(ddb([~1],i),~3)|4. by label value --> measure variables of the atom if its label ~LabelName~ is ~=~ the value ~1~./],  [=(icon(i),iconbyname([~1]))|5. by icon --> measure variables of the atom if its icon equals the icon by name ~IconName~./],  [~1|6. by user logic --> if ~true~ is true the variables of the atom will be measured.] ))], [Returns predefined logics], [GetObjectivesOrRequirements(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetHistoryViewerStartTimes], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[0],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[60],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[mins(60)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[hr(8)],Char(1),[objectend]) ))], [Returns predefined logics], [GetHistoryViewerStartTimes], 0, [Kernel Functions.atm]);
DefineFunction([GetHistoryViewerEndTimes], [Various], 0, 0, [Do( Concat(  Concat(Char(1),[objectstart],Char(1),[code:],[time],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[60],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[mins(60)],Char(1),[objectend]),  Concat(Char(1),[objectstart],Char(1),[code:],[hr(8)],Char(1),[objectend]) ))], [Returns predefined logics], [GetHistoryViewerEndTimes], 0, [Kernel Functions.atm]);
DefineFunction([GetAutofitDataExpression], [Various], 1, 1, [Do( Case(p(1),  [ExcelRead(count, ~1)|1. From an active DDE connection to an Excel worksheet, read the values in columnnumber ~1~ ],  [~2(count, ~1)|2. From a table atom defined as ~MyTable~, use the values in columnnumber ~1~],  [cell(count, ~2, ~1)|2. From an arbitrary atom ~first(model)~, use the values in columnnumber ~1~] ))], [Returns predefined logics], [GetAutofitDataExpression], 0, [Kernel Functions.atm]);
DefineFunction([t-GetSetUpCode], [Various], 2, 2, [Do( sDdb([t-setupcode],p(1),c), sDdb([t-oldsetupcode],  If(=(output(c),0),   p(2),   Ddb([t-memsetupcode],c)  ),  c ), sDdb([t-memsetupcode], Ddb([t-setupcode],c),c), Ddb([t-setupcode],c))], [Enter helptext], [t-GetSetUpCode(e1, e2)], 0, [Kernel Functions.atm]);
DefineFunction([t-FindQueuePos], [Various], 2, 2, [Do( sDdb([t-fqp],p(1),c), If( p(2),  +(   IndexMatch(    -(     Content(c),1    ),    1,    <=(     Label(Ddb([t-fqp],c),Last(c)),     Label(Ddb([t-fqp],c),Rank(Count,c))    )   ),   1  ),  +(   IndexMatch(    -(     Content(c),1    ),    1,    >=(     Label(Ddb([t-fqp],c),Last(c)),     Label(Ddb([t-fqp],c),Rank(Count,c))    )   ),   1  ) ))], [Searches queue for position, e1 is labelname, e2 is 1 or 0 (min or max)], [t-FindQueuePos(e1,e2)], 0, [Kernel Functions.atm]);
DefineFunction([UpdateCameraMenuItems], [Gui], 0, 0, [do( GuiControl([MainMenu]),  { if only the empty menu item is available, add the default camera menu item } if(  and(   GuiMenuItem([mniCurrentCamera], [ChildCount]) = 1,   CompareText(GuiMenuItem([mniCurrentCamera], [ChildName], 1), [mniEmptyCamera])  ),  do(   AddCameraMenuItem([Default], 0, true),   GuiDestroyMenuItem([mniEmptyCamera])  ) ),  { remove all camera menu items, except default } if(  GuiMenuItem([mniCurrentCamera], [ChildCount]) > 1,  do(   Repeat(    GuiMenuItem([mniCurrentCamera], [ChildCount])-1,    GuiDestroyMenuItem(GuiMenuItem([mniCurrentCamera], [ChildName], 2))   )  ) ),  { add all current camera menu items } v := 1, ForAtomTreeUnder(  vtp(GuiControl([Engine3D], GuiGet([DisplayAtom]))),  do(   if(    label([CameraID], a) <> 0,    do(     AddCameraMenuItem(      Name(a),      Label([CameraID], a),      CurrentCamera(GuiControl([Engine3D], GuiGet([EngineID]))) = Label([CameraID], a),      ExecString([Camera_GetHotKey(a)])     ),     if(      CurrentCamera(GuiControl([Engine3D], GuiGet([EngineID]))) = Label([CameraID], a),      { set 'v' to 0 if a camera menu item was checked }      v := 0     )    )   )  ) ),  { check the default camera menu item according to 'v' } GuiMenuItem(  GuiMenuItem([mniCurrentCamera], [ChildName], 1),  [Checked],  v ))], [Updates the camera menu items of the 3D windows. Assumes that the current Gui Instance is a 3D window.], [UpdateCameraMenuItems], 0, [Kernel Functions.atm]);
DefineFunction([AddCameraMenuItem], [Gui], 3, 4, [Do( dim([strCamMenuItem], vbString, Concat([mniCamera],string(p(2))) ), GUIControl([MainMenu]), GUIcreateMenuItem(strCamMenuItem, [mniCurrentCamera]), GUIMenuItem(  strCamMenuItem,  [Caption],  p(1) ), GUIMenuItem(  strCamMenuItem,  [Checked],  p(3) ), GUIMenuItem(  strCamMenuItem,  [shortcut],  p(4) ), GUIMenuItem(  strCamMenuItem,  [Code],  concat(   [    do(     SetActive3D(      GUIControl([Engine3D], GUIGet([EngineID]))     ),          { change the camera }     SetCurrentCamera(], string(p(2)), [)    )   ]  ) ))], [Adds a camera menu item to the mniCurrentCamera menu item.e1 = Name of camerae2 = The ID of the Camerae3 = Item checkede4 = Hotkey], [AddCameraMenuItem([Camera1], 1)], 0, [Kernel Functions.atm]);
DefineFunction([GetTriggerReset], [Various], 0, 0, [Do(
 Concat(
 concat(char(1),[objectstart],char(1),[code:],[0],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Label([?],c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Name(c) := [?]],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := IconByName([?])],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Color(c) := coloryellow],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetSize(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetLoc(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CallOperators(AtomByName([Team],Model),1)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Freeoperators(AtomByName([Team],Model),First(c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(? = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(Label([?],c) = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(comparetext(name(c),[?]),?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseOutput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseInput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[do(CloseOutput(out(?,c)),CloseInput(out(?,c)))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseOutput(out(Count,c))))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseInput(out(Count,c))))],char(1),[objectend])
 )
)
], [Returns predefined logics], [GetTriggerReset], 0, [Kernel Functions.atm]);
DefineFunction([GetTriggerBreakdown], [Various], 0, 0, [Do(
 Concat(
 concat(char(1),[objectstart],char(1),[code:],[0],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Label([?],c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Name(c) := [?]],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := IconByName([?])],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Color(c) := coloryellow],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetSize(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetLoc(?,?,?,c)],char(1),[objectend]), 
 concat(char(1),[objectstart],char(1),[code:],[Freeoperators(AtomByName([Team],Model),First(c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(? = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(Label([?],c) = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(comparetext(name(c),[?]),?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseOutput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseInput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[do(CloseOutput(out(?,c)),CloseInput(out(?,c)))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseOutput(out(Count,c))))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseInput(out(Count,c))))],char(1),[objectend])
 )
)


], [Returns predefined logics], [GetTriggerBreakdown], 0, [Kernel Functions.atm]);
DefineFunction([GetTriggerEndOfSetup], [Various], 0, 0, [Do(
 Concat(
 concat(char(1),[objectstart],char(1),[code:],[0],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Label([?],c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Name(c) := [?]],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := IconByName([?])],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Color(c) := coloryellow],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetSize(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetLoc(?,?,?,c)],char(1),[objectend]), 
 concat(char(1),[objectstart],char(1),[code:],[Freeoperators(AtomByName([Team],Model),First(c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(? = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(Label([?],c) = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(comparetext(name(c),[?]),?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseOutput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseInput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[do(CloseOutput(out(?,c)),CloseInput(out(?,c)))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseOutput(out(Count,c))))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseInput(out(Count,c))))],char(1),[objectend])
 )
)

], [Returns predefined logics], [GetTriggerEndOfSetup], 0, [Kernel Functions.atm]);
DefineFunction([GetTriggerRepair], [Various], 0, 0, [Do(
 Concat(
 concat(char(1),[objectstart],char(1),[code:],[0],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Label([?],c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Name(c) := [?]],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := IconByName([?])],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Color(c) := coloryellow],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetSize(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetLoc(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CallOperators(AtomByName([Team],Model),1)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Freeoperators(AtomByName([Team],Model),First(c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(? = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(Label([?],c) = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(comparetext(name(c),[?]),?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseOutput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseInput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[do(CloseOutput(out(?,c)),CloseInput(out(?,c)))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseOutput(out(Count,c))))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseInput(out(Count,c))))],char(1),[objectend])
 )
)
], [Returns predefined logics], [GetTriggerRepair], 0, [KernelFunctions.atm]);
DefineFunction([GetTriggerLoadUnload], [Various], 0, 0, [Do(
 Concat(
 concat(char(1),[objectstart],char(1),[code:],[0],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Label([?],c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Name(c) := [?]],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := ?],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Icon(c) := IconByName([?])],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Color(c) := coloryellow],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetSize(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[SetLoc(?,?,?,c)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CallOperators(AtomByName([Team],Model),1)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Freeoperators(AtomByName([Team],Model),First(c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(? = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(Label([?],c) = ?,?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[if(comparetext(name(c),[?]),?,?)],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseOutput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[CloseInput(out(?,c))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[do(CloseOutput(out(?,c)),CloseInput(out(?,c)))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseOutput(out(Count,c))))],char(1),[objectend]),
 concat(char(1),[objectstart],char(1),[code:],[Repeat(NrOC(c),if(AtomExists(out(Count,c)),CloseInput(out(Count,c))))],char(1),[objectend])
 )
)

], [Returns predefined logics], [GetTriggerLoadUnload], 0, [KernelFunctions.atm]);
DefineFunction([GetSendToIntersections], [Various], 1, 1, [Do( Case(p(1),  [~1|1. Specific channel: always send to channel ~1~],  [min(nroc(c),-(+(nroc(c),1),indexmatch(nroc(c),1,icopen(ocicno(-(+(nroc(c),1),count),c),out(-(+(nroc(c),1),count),c)))))|2. An open channel (First channel first): search, starting from the first channel, and send to the first open channel found.],  [max(1,indexmatch(nroc(c),1,icopen(ocicno(count,c),out(count,c))))|3. An open channel (Last channel first): search, starting from the last channel, and send to the first open channel found.],  [indexmax(nroc(c),*(icopen(ocicno(count,c),out(count,c)),random(100000)))|4. A random open channel: choose a random channel from all the open output channels.],  [bernoulli(~1,~2,~3)|5. By percentage: ~90~% of products go to channel ~1~, the remaining percentage go to channel ~2~],  [if(comparetext(name(rank(~1,c)),[~2]),~3,~4)|6. By atom name: if the atom name of the ~1~st atom in the queue matches ~AtomName~ then send to channel ~1~ else ~2~.],  [if(ddb([~1],rank(~2,c))<=0,~3,min(ddb([~1],rank(~2,c)),nroc(c)))|7. By label value (direct): the channel number is written directly on the label named ~LabelName~ of the ~1~st atom in the queue. If the label value is 0 then send to channel ~1~.],  [if(~3(ddb([~1],rank(~2,c)),~4),~5,~6)|8. By label value (conditional): if the value on the label named ~LabelName~ of the ~1~st atom in the queue is ~<~ the value ~1~ then send to channel ~1~ else ~2~.],  [if(comparetext(ddb([~1],rank(~2,c)),[~3]),~4,~5)|9. By label text: if the text on the label named ~LabelName~ of the ~1~st atom in the queue matches ~text~ then send to channel ~1~ else ~2~.],  [if(~2(~1,~3),~4,~5)|10. Conditional statement: If ~1~ is ~>~ than ~0~ then send to channel ~1~ else send to channel ~2~],  [if(=(icon(rank(~1,c)),iconbyname([~2])),~3,~4)|11. By icon name: if the icon name of the ~1~st atom in the queue matches ~IconName~ then send to channel ~1~ else ~2~.],  [if(~2(icon(rank(~1,c)),~3),~4,~5)|12. By icon number: if the icon number of the ~1~st atom in the queue is ~=~ the value ~1~ then send to channel ~1~ else ~2~.],  [indexmatchrank(nroc(c),atomexists(out(count,c)),true,+(mod(output(c),countmatch(nroc(c),atomexists(out(count,c)),true)),1))|13. Round robin: all outputchannels are used in rotation.  If channel is closed, then wait till open.],  [indexmin(nroc(c),if(icopen(ocicno(count,c),out(count,c)),content(out(count,c)),1e50))|14: Smallest queue: Send to the channel connected to the atom with the smallest queue],  [indexmax(nroc(c),content(out(count,c)))|15: Largest queue: Send to the channel connected to the atom with the largest queue],  [~3(~1,~2)|16: Lookup table: Send to the channel specified in row ~1~ column ~2~ of global table named ~table1~],  [do(inc(ddb([t_rr],c)),if(ddb([t_rr],c)>nroc(c),sddb([t_rr],1,c)),loopuntil(icopen(ocicno(ddb([t_rr],c),c),out(ddb([t_rr],c),c)),do(inc(ddb([t_rr],c)),if(ddb([t_rr],c)=nroc(c)+1,sddb([t_rr],1,c))),nroc(c)),ddb([t_rr],c))|17. Round robin if available: all outputchannels are used in rotation if channel is available.  If channel is closed, then next available channel is chosen.],  [indexmatch(nroc(c),1,or(content(out(count,c))=0,icon(first(c))=icon(last(out(count,c)))))|18. Matching icon number or empty: Sends to a queue containing products of same icon. If no icons match, then sends to first empty queue starting with last output channel.],  [indexmin(nroc(c),content(out(count,c))+content(out(1,out(count,c))))|19. Lowest queue of next two atoms: Sends to the output channel connected to the lowest queue, where lowest queue takes into account the next TWO atoms],  [~1|20. By user: enter your own 4DScript expression resulting in a value between 1 and the number of channels: ~1~. You can press the small button for the 4DScript editor.],  [duniform(1,nroc(c))|21. Random channel: randomly choose a channel. If the channel is open then send to it, otherwise choose again when any channel opens.] ))], [Select the next destination. Specific solution for atoms without open output channels.], [GetSendToIntersections(1)], 0, [Kernel Functions.atm]);
DefineFunction([GetSendToSpeedChangeAccConv], [Various], 1, 1, [Do( Case(p(1),  [~1|1. Specific channel: always send to channel ~1~],  [min(nroc(c),-(+(nroc(c),1),indexmatch(nroc(c),1,ocready(-(+(nroc(c),1),count),c))))|2. An open channel (First channel first): search, starting from the first channel, and send to the first open channel found.],  [max(1,indexmatch(nroc(c),1,ocready(count,c)))|3. An open channel (Last channel first): search, starting from the last channel, and send to the first open channel found.],  [indexmax(nroc(c),*(ocready(count,c),random(100000)))|4. A random open channel: choose a random channel from all the open output channels.],  [bernoulli(~1,~2,~3)|5. By percentage: ~90~% of products go to channel ~1~, the remaining percentage go to channel ~2~],  [if(comparetext(name(rank(~1+1,c)),[~2]),~3,~4)|6. By atom name: if the atom name of the ~1~st atom in the queue matches ~AtomName~ then send to channel ~1~ else ~2~.],  [if(ddb([~1],rank(~2+1,c))<=0,~3,min(ddb([~1],rank(~2+1,c)),nroc(c)))|7. By label value (direct): the channel number is written directly on the label named ~LabelName~ of the ~1~st atom in the queue. If the label value is 0 then send to channel ~1~.],  [if(~3(ddb([~1],rank(~2+1,c)),~4),~5,~6)|8. By label value (conditional): if the value on the label named ~LabelName~ of the ~1~st atom in the queue is ~<~ the value ~1~ then send to channel ~1~ else ~2~.],  [if(comparetext(ddb([~1],rank(~2+1,c)),[~3]),~4,~5)|9. By label text: if the text on the label named ~LabelName~ of the ~1~st atom in the queue matches ~text~ then send to channel ~1~ else ~2~.],  [if(~2(~1,~3),~4,~5)|10. Conditional statement: If ~1~ is ~>~ than ~0~ then send to channel ~1~ else send to channel ~2~],  [if(=(icon(rank(~1+1,c)),iconbyname([~2])),~3,~4)|11. By icon name: if the icon name of the ~1~st atom in the queue matches ~IconName~ then send to channel ~1~ else ~2~.],  [if(~2(icon(rank(~1+1,c)),~3),~4,~5)|12. By icon number: if the icon number of the ~1~st atom in the queue is ~=~ the value ~1~ then send to channel ~1~ else ~2~.],  [indexmatchrank(nroc(c),atomexists(out(count,c)),true,+(mod(output(c),countmatch(nroc(c),atomexists(out(count,c)),true)),1))|13. Round robin: all outputchannels are used in rotation.  If channel is closed, then wait till open.],  [indexmin(nroc(c),if(ocready(count,c),content(out(count,c)),1e50))|14: Smallest queue: Send to the channel connected to the atom with the smallest queue],  [indexmax(nroc(c),content(out(count,c)))|15: Largest queue: Send to the channel connected to the atom with the largest queue],  [~3(~1,~2)|16: Lookup table: Send to the channel specified in row ~1~ column ~2~ of global table named ~table1~],  [do(inc(ddb([t_rr],c)),if(ddb([t_rr],c)>nroc(c),sddb([t_rr],1,c)),loopuntil(ocready(ddb([t_rr],c),c),do(inc(ddb([t_rr],c)),if(ddb([t_rr],c)=nroc(c)+1,sddb([t_rr],1,c))),nroc(c)),ddb([t_rr],c))|17. Round robin if available: all outputchannels are used in rotation if channel is available.  If channel is closed, then next available channel is chosen.],  [indexmatch(nroc(c),1,or(content(out(count,c))=0,icon(Rank(2,c))=icon(last(out(count,c)))))|18. Matching icon number or empty: Sends to a queue containing products of same icon. If no icons match, then sends to first empty queue starting with last output channel.],  [indexmin(nroc(c),content(out(count,c))+content(out(1,out(count,c))))|19. Lowest queue of next two atoms: Sends to the output channel connected to the lowest queue, where lowest queue takes into account the next TWO atoms],  [~1|20. By user: enter your own 4DScript expression resulting in a value between 1 and the number of channels: ~1~. You can press the small button for the 4DScript editor.],  [duniform(1,nroc(c))|21. Random channel: randomly choose a channel. If the channel is open then send to it, otherwise choose again when any channel opens.] ))], [Select the next destination. Specific solution for Speed Changing Accumulating Conveyor, as there is a sub atom that is displacing the product from the first position.], [GetSendToSpeedChangeAccConv(1)], 0, [Kernel Functions]);
DefineFunction([Functions_Cut], [Various], 1, 1, [do(  var([atmFC], vbAtom, p(1)),  var([strFunctionText], vbString),  var([strFunctionName], vbString),  var([strCode], vbString),  var([strHelpText], vbString),  var([strExample], vbString),  var([strCategory], vbString),  var([strCreator], vbString),  var([valParMin], vbValue),  var([valParMax], vbValue),  var([valCounter], vbValue, 1),    var([atmC], vbAtom),    {**Remove old**}  ForAtomTreeUnder(    atmFC,    do(      atmC := a,      Repeat(        Label([Functions_NrCut], atmC),        Label(Concat([Functions_Cut], String(Count)), atmC) := 0      ),      Label([Functions_NrCut], atmC) := 0,      strFunctionText := [],          While(        StringLength(FunctionOnAtomName(atmC, valCounter)) > 0,            do(          inc(Label([Functions_NrCut], atmC)),                    Label(Concat([Functions_Cut], String(valCounter)), atmC) := 0,                    strFunctionName := FunctionOnAtomName(atmC, valCounter),           strCategory := FunctionOnAtomInfo(atmC, valCounter, [category]),          valParMin := FunctionOnAtomInfo(atmC, valCounter, [minparams]),          valParMax:= FunctionOnAtomInfo(atmC, valCounter, [maxparams]),          strCode := FunctionOnAtomInfo(atmC, valCounter, [code]),                strHelpText := FunctionOnAtomInfo(atmC, valCounter, [helptext]),           strExample := FunctionOnAtomInfo(atmC, valCounter, [syntaxexample]),           strCreator := FunctionOnAtomInfo(atmC, valCounter, [creator]),                     strFunctionText := ParString(strFunctionName, strCategory, string(valParMin), String(valParMax), strCode, strHelpText, strExample, strCreator),                     {**Workaround for ED-413**}          strFunctionText := StringReplace(strFunctionText, [.>], [. >], SR_REPLACE_ALL),          Label(Concat([Functions_Cut], String(valCounter)), atmC) := strFunctionText,          inc(valCounter)           )      )    ),    1  ))], [Copies the defined functions of atom e1], [Functions_Cut(c)], 0, [Kernel Functions.atm]);
DefineFunction([Functions_Paste], [Various], 1, 1, [do(  var([atmFC], vbAtom, p(1)),  var([atmC], vbAtom),  var([strFunctionText], vbString),  var([strFunctionName], vbString),  var([strCode], vbString),  var([strHelpText], vbString),  var([strExample], vbString),  var([strCategory], vbString),  var([strCreator], vbString),  var([valParMin], vbValue),  var([valParMax], vbValue),  var([valDoNotPaste], vbValue, False),     {**Check if one of the functions exists. If so do not paste**}  ForAtomTreeUnder(    atmFC,    do(      atmC := a,      LoopUntil(        valDoNotPaste = True,            do(          strFunctionText := Label(Concat([Functions_Cut], String(Count)), atmC),                              strFunctionName := StringPar(strFunctionText, 1),             if(            FunctionExists(strFunctionName),            valDoNotPaste := True          )        ),        Label([Functions_NrCut], atmC)      )    ),    1  ),    if(    valDoNotPaste = True,    ForAtomTreeUnder(      atmFC,      do(        atmC := a,        Repeat(          Label([Functions_NrCut], atmC),          do(            Label(Concat([Functions_Cut], String(Count)), atmC) := 0          )        ),        Label([Functions_NrCut], atmC) := 0      ),      1    ),    do(           {**Preregister functions**}      ForAtomTreeUnder(        atmFC,        do(          atmC := a,          Repeat(            Label([Functions_NrCut], atmC),            do(              strFunctionText := Label(Concat([Functions_Cut], String(Count)), atmC),              strFunctionName := StringPar(strFunctionText, 1),                              valParMin := Value(StringPar(strFunctionText, 3)),               valParMax := Value(StringPar(strFunctionText, 4)),                            PreregisterFunction(strFunctionName, valParMin, valParMax)            )          )                  ),        1      ),       {**Register functions**}         ForAtomTreeUnder(        atmFC,        do(          atmC := a,             Repeat(            Label([Functions_NrCut], atmC),            do(              strFunctionText := Label(Concat([Functions_Cut], String(Count)), atmC),              Label(Concat([Functions_Cut], String(Count)), atmC) := 0,                            strFunctionName := StringPar(strFunctionText, 1),                          strCategory := StringPar(strFunctionText, 2),                    valParMin := Value(StringPar(strFunctionText, 3)),               valParMax := Value(StringPar(strFunctionText, 4)),              strCode := StringPar(strFunctionText, 5),              strHelpText := StringPar(strFunctionText, 6),              strExample := StringPar(strFunctionText, 7),              strCreator := StringPar(strFunctionText, 8),                          a := atmC,              DefineFunction(                                {**Name**}                strFunctionName,                                 {**Category**}                strCategory,                                {**Params**}                valParMin,                valParMax,                                {**Code**}                strCode,                                {**Help Text**}                strHelpText,                              {**Syntax Example**}                strExample,                                {**Scope**}                0,                                {**Creator**}                    strCreator              )            )          ),                    Label([Functions_NrCut], atmC) := 0        ),        1      )          )  )  )], [Pastes the cutted defined functions on atom e1], [Functions_Paste(c)], 0, [Kernel Functions.atm]);
DefineFunction([AtomTreePaste_withFunctions], [Various], 1, 1, [if(  AtomTreeFocus = True,        {**Atom is paste to the tree**}    do(    var([atmNew], vbAtom),    var([atmTree], vbAtom),    var([valRank], vbValue),        {**Make sure that there are no errors shown due to unregistered function**}    silent(1),    close(ErrorTracer),    atmTree := TreeAtom,        if(      p(1) = 1,      do(          AtomTreePaste(True),        atmNew := Last(atmTree)                     ),      do(        valRank := GetRank(atmTree) + 1,                AtomTreePaste(False),        atmNew := Last(Up(atmTree)),                Rank(atmNew) := valRank              )    ),      Functions_Paste(atmNew),    Error([ ]),    ErrorClear,    TreeAtom := atmNew,    AtomTreeRefresh,    silent(0)  ),    {**Else text is pasted in the atom editor**}  AtomTreePaste(False))], [e1 = Under the selected atom (True) or at the same level false], [AtomTreePaste_withFunctions(True)], 0, [Kernel Functions.atm]);
DefineFunction([AtomTreeCut_withFunctions], [Various], 0, 0, [if(  AtomTreeFocus = True,      {**Atom is cut from the tree**}  do(    Functions_Cut(TreeAtom),     AtomTreeCut  ),    {**Else text is cut from the atom editor**}  AtomTreeCut)], [Cuts an atom with functions], [AtomTreeCut_withFunctions(True)], 0, [Kernel Functions.atm]);
DefineFunction([createviewermodelLayout], [Various], 0, 8, [Do( GuiRegister(pdir([Apps\modelLayout2D.GUI]), 1),  { find new model layout name } v := 0, t := Concat([modelLayout], string(v+1)), LoopUntil(GuiInstance(t) = 0,  Do(   v := v + 1,   t := Concat([modelLayout], string(v+1))  ) ),  Guicreate([modelLayout], t),  { set view atom } If (ParamCount = 0,  GuiControl([Engine2D], GuiSet([DisplayAtom], model)),  GuiControl([Engine2D], GuiSet([DisplayAtom], p(1))) ),  { position window } GUIControl([modelLayout], GUISet([Left], 10 + v * 20)), GUIControl([modelLayout], GUISet([Top], 90 + v * 20)), GUIControl([modelLayout], GUISet([Width], ScreenWidth - 30 - (v * 20))), GUIControl([modelLayout], GUISet([Height], ScreenHeight - 200)),  { Set the parameters passed to this function } If (ParamCount > 1,  GUIControl([Engine2D], GUIEvent([Refresh], p(2))) ), If (ParamCount > 2,  GUIControl([Engine2D], GUIEvent([AtomClick], p(3))) ), If (ParamCount > 3,  GUIControl([Engine2D], GUIEvent([AtomDrop], p(4))) ), If (ParamCount > 4,  GUIControl(0, GUISet([Caption], p(5))) ), If (ParamCount > 5,  GUIControl([Engine2D], GUISet([ShowGrid], p(6) > 0)) ), If (ParamCount > 6,  GUIControl([Engine2D], GUISet([ShowChannels], p(7) > 0)) ), If (ParamCount > 7,  GUIControl([Engine2D], GUIEvent([ViewPointChange], p(8))) ),  { set the right flags } GuiControl([MainMenu]), GuiMenuItem([mniGridEnabled], [Checked],  GuiControl([Engine2D], GuiGet([ShowGrid])) ), GuiMenuItem([mniChannelsEnabled], [Checked],  GuiControl([Engine2D], GuiGet([ShowChannels])) ), GuiMenuItem([mniChannelsEnabled], [Checked],  GuiControl([Engine2D], GuiGet([ShowChannels])) ), GuiMenuItem([mniStatusBar], [Checked],  GuiControl([Engine2D], GuiGet([ShowStatusBar])) ), GuiMenuItem([mniSnapToGrid], [Checked],  GuiControl([Engine2D], GuiGet([SnapToGrid])) ),  Case(  GuiControl([Engine2D], GuiGet([SelectionMode])),    { SM_LEVELSELECT }  Do(   GuiMenuItem([mniLevelSelect], [Checked], True),   GuiMenuItem([mniLevelSelect], [Checked], False)  ),    { SM_SELECTVISIBLE }  Do(   GuiMenuItem([mniLevelSelect], [Checked], False),   GuiMenuItem([mniLevelSelect], [Checked], True)  ) ),  GUIMenuItem([mniGridEnabled], [Checked], GUIControl([Engine2D], GUIGet([ShowGrid]))), GUIMenuItem([mniSelectVisible], [Checked], GuiControl([Engine2D], GuiGet([SelectionMode])) = SM_SELECTVISIBLE), GUIMenuItem([mniLevelSelect], [Checked], GuiControl([Engine2D], GuiGet([SelectionMode])) = SM_LEVELSELECT), GUIMenuItem([mniCustomUnit], [Checked], True), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[0.001]), If (v, do(GUIMenuItem([mniMM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[0.01]), If (v, do(GUIMenuItem([mniCM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[0.1]), If (v, do(GUIMenuItem([mniDIM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[1]), If (v, do(GUIMenuItem([mniM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[10]), If (v, do(GUIMenuItem([mniDAM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[100]), If (v, do(GUIMenuItem([mniHM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))), v := CompareText(GuiControl([Engine2D], GuiGet([GridSize])),[1000]), If (v, do(GUIMenuItem([mniKM], [Checked], True), GUIMenuItem([mniCustomUnit], [Checked], False))),  GuiMenuItem([mniBackgroundVisible], [Checked], Background2DVisible),  { show the form } GUIControl(0, GUISet([Visible], True)))], [This function creates a viewer model layout window.], [createviewermodelLayout(c)], 0, [Kernel Functions.atm]);
DefineFunction([createviewermodelView], [Various], 0, 7, [Do( GuiRegister(pdir([Apps\modelView2D.GUI]), 1),  { find new model view name } v := 0, t := Concat([modelView], string(v+1)), LoopUntil(GuiInstance(t) = 0,  Do(   v := v + 1,   t := Concat([modelView], string(v+1))  ) ),  Guicreate([modelView], t),  { set view atom } If (ParamCount = 0,  GuiControl([Engine2D], GuiSet([DisplayAtom], model)),  GuiControl([Engine2D], GuiSet([DisplayAtom], p(1))) ),  { set events } If (ParamCount > 1,  GUIControl([Engine2D], GUIEvent([Refresh], p(2))) ),  If (ParamCount > 2,  GUIControl([Engine2D], GUIEvent([AtomClick], p(3))) ),  If (ParamCount > 3,  GUIControl(0, GUISet([Caption], p(4))) ),  If (ParamCount > 4,  GUIControl([Engine2D], GUISet([ShowGrid], p(5) > 0)) ),  If (ParamCount > 5,  GUIControl([Engine2D], GUISet([ShowChannels], p(6) > 0)) ),  If (ParamCount > 6,  GUIControl([Engine2D], GUIEvent([ViewPointChange], p(7))) ),  { position window } GUIControl(0, GUISet([Left], 10 + v * 20)), GUIControl(0, GUISet([Top], 90 + v * 20)), GUIControl(0, GUISet([Width],  ScreenWidth - 30 - (v * 20))), GUIControl(0, GUISet([Height], ScreenHeight - 200)), { show the form } GUIControl(0, GUISet([Visible], True)))], [creates a model view window.], [createviewermodelView(c)], 0, [Kernel Functions.atm]);
DefineFunction([createviewer3DmodelView], [Various], 1, 1, [Do( GuiRegister(pdir([Apps\modelView3D.GUI]), 1),  { find new model view name } v := 0, t := Concat([modelView3D_], string(v+1)), LoopUntil(GuiInstance(t) = 0,  Do(   v := v + 1,   t := Concat([modelView3D_], string(v+1))  ) ),  Guicreate([modelView3D], t),  { position window } GUIControl([modelView3D], GUISet([Left], 10 + v * 20)), GUIControl([modelView3D], GUISet([Top], 90 + v * 20)), GUIControl([modelView3D], GUISet([Width], ScreenWidth - 30 - (v * 20))), GUIControl([modelView3D], GUISet([Height], ScreenHeight - 200)), { set right flags }  GUIControl([MainMenu]),  GuiMenuItem([mniStatusBar], [Checked],  GuiControl([Engine3D], GuiGet([ShowStatusBar])) ),  GuiMenuItem([mniTarGet], [Checked],  GuiControl([Engine3D], GuiGet([CameraMode]) = CT_TARGET) ),  GuiMenuItem([mniFreehand], [Checked],  GuiControl([Engine3D], GuiGet([CameraMode]) = CT_FREEHAND) ),  GuiMenuItem([mniFreehand], [Checked],  GuiControl([Engine3D], GuiGet([CameraMode]) = CT_FREEHAND) ),   GuiMenuItem([mniGrid], [Checked],  GuiControl([Engine3D], GuiGet([ShowGrid])) ),   GuiMenuItem([mniSelectedAtom], [Checked],  GuiControl([Engine3D], GuiGet([ShowSelectedAtom])) ),  { does user have VR support?} If(  AddOnAvailable(PT_VIRTUAL_REALITY),  Do(   GUIControl([MainMenu]),   GUIcreateMenuItem([mniVR], [mniView]),   GUIMenuItem([mniVR], [caption], [Virtual reality]),   GUIMenuItem([mniVR], [visible], true),   GUIMenuItem([mniVR], [code], [do(SetActive3d(GUIControl([Engine3D], GUIGet([ID]))), fullscreen(1, 0, 0, 0, 0, 1))])  ) ),  { set view atom } If( ParamCount = 0,  GuiControl([Engine3D], GuiSet([DisplayAtom], model)),  GuiControl([Engine3D], GuiSet([DisplayAtom], p(1))) ),  UpdateCameraMenuItems,  { show the form } GUIControl(0, GUISet([Visible], True)))], [creates a 3D model view window.], [createviewer3DmodelView(c)], 0, [Kernel Functions.atm]);
DefineFunction([FillPredefinedLogicList], [Various], 2, 2, [do( var([strControlName], vbString, p(1)), var([strExpression], vbString, Concat(p(2), [(Count)])), var([strLogic], vbString), GuiControl(  strControlName,  Repeat(   100000,   do(    strLogic := ExecString(strExpression),    if(StringLength(strLogic) = 0, return),    GuiList([Lines], [Add], strLogic)   )  ) ))], [Enter helptext], [FillPredefinedLogicsList([seSendTo],  [getSendTo])], 0, [Kernel Functions.atm]);
Set(Icon(a), 
	RegisterIcon(pDir([media\images\default.jpg]), [default.jpg]));
SetMaterial(
	RegisterMaterial([Default], 8421504, 8421504, 3289650, 0, 0.100000001490116, 0, false, false, 1, 0), 1, a);
Set(Version(a), 7.3);
SetTreeIcon(pDir([Media\icons\Tools.ico]));
Set(DdbRec, [>t-nocreate:1.]);
int001(4);
SetSize(1, 1, 1);
LockPosition(false);
LockSize(false);
DisableIconRotation(false);
SetProductCode([]);
int024;
SetStatus(0);
int018;
int007;
