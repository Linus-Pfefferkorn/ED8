

{Preregister functions}

PreregisterFunction([CTU_Output_Atom_Get_Rotation], 3, 3);
PreregisterFunction([CTU_Input_Atom_Get_Rotation], 3, 3);
PreregisterFunction([CTU_Input_Atom_Set_Table], 3, 3);
PreregisterFunction([CTU_Output_Atom_Set_Table], 3, 3);
PreregisterFunction([CTU_IsCTU], 1, 1);
PreregisterFunction([CTU_Change_Product_Z_Rotation], 2, 2);
PreregisterFunction([CTU_Detect_Collision], 1, 1);
PreregisterFunction([CTU_Change_Passing_Atom_Drawing], 1, 1);
PreregisterFunction([CTU_Set_Product_Location], 2, 2);
PreregisterFunction([CTU_Detect_Transfer_Time], 1, 1);
PreregisterFunction([CTU_Detect_Transport_Length], 1, 1);
PreregisterFunction([CTU_Change_Product_XY_Size], 2, 2);
PreregisterFunction([CTU_Change_Product_Translation_On_Entered], 2, 2);
PreregisterFunction([CTU_Adjust_Product_Rotation_As], 1, 1);
PreregisterFunction([CTU_Change_Product_Translation_On_Exited], 1, 1);
PreregisterFunction([CTU_3Ddraw_ctu_without_icon], 1, 1);
PreregisterFunction([CTU_3Ddraw_ctu_with_icon], 1, 1);
PreregisterFunction([CTU_2Ddraw_direction_arrows], 1, 1);
PreregisterFunction([CTU_3Ddraw_ctu_chain_conveyor_animated], 1, 1);
PreregisterFunction([CTU_3Ddraw_ctu_chain_conveyor], 1, 1);


{Atom: Corner Transfer Unit}

sets;
BaseClass;
CreateAtom(a, s, [], 1, false);
int023([Corner Transfer Unit], 10789024, 66802);
DefineFunction([CTU_Output_Atom_Get_Rotation], [Conveyors], 3, 3, [do(
 var([CTUoutputatomangle],vbValue),
 
 {--get rotationas of connected input atom--}
 CTUoutputatomangle :=  
  if(
   Att([IsConveyor],p(1)) > 0,
   {--Connected atom is from conveyors category--}
   Case(
    {--Identifier of conveyor category--}
    Att([IsConveyor],p(1)),
    
    {--Case 1 : Advanced Non Accumulating Conveyor Straight--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 2 : Advanced Non Accumulating Conveyor Curved--}
    do(
     {--Attribute "startangle"--}
     Round(mod(Att([startangle],p(1)),360),3)
    ),
    
    {--Case 3 : Advanced Accumulating Conveyor Straight--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 4 : Advanced Accumulating Conveyor Curved--}
    do(
     {--Attribute "startangle"--}
     Round(mod(Att([startangle],p(1)),360),3)
    ),
    
    {--Case 5 : Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 6 : Right Curved Accumulating Conveyor--}
    do(
     {--Attribute "startangle"--}
     Round(mod(Att([startangle],p(1)),360),3)
    ),
    
    {--Case 7 : Left Curved Accumulating Conveyor--}
    do(
     {--Attribute "startangle"--}
     Round(mod(Att([startangle],p(1)),360),3) - 180
    ),
    {--Case 8 : Non Accumulating Conveyor--}
    do(
     
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 9 : Left Curved Non Accumulating Conveyor--}
    do(
     {--Attribute "startangle"--}
     Round(mod(Att([startangle],p(1)),360),3) - 180
    ),
    
    {--Case 10 : Right Curved Non Accumulating Conveyor--}
    do(
     {--Attribute "startangle"--}
     Round(mod(Att([startangle],p(1)),360),3)
    ),
    
    {--Case 11 : Speed Changing Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 12 : Buffer Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 13 : Fast Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 14 : Fast Non Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 15 : Turntable Unit--}
    do(
     {--Angle from table--}
     Round(mod(Cell( OcIcNo(p(3),p(2)), 1, p(1) ),360),3)
    ),
    
    {--Case 16 : Corner Transfer Unit--}
    do(
     Round(
      Mod(
       {--rotationas of CTU--}
       Att([InitialRotation],p(2)) +
     
       Case(
        WhichIsTrue(
         {--x positiv 0°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 0,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 0
          ),
          
         {--x positiv 90°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 90,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 90
          ),
          
         {--x positiv 180°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 0,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 180
          ),
          
         {--x positiv 270°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = -90,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 90
          ),
        
         {--x positiv 0° + InitialRotation--}
         and(
          ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 45,
          ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) > -45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >=  0
         ),
         {--y negativ 90° + InitialRotation--}
         and(
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 90,
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 135,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  45
         ),
         {--x negativ 180° + InitialRotation--}
         and(
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 45,
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) > -45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 180,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  135
         ),
         {--y positiv 270° + InitialRotation--}
         and(
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= -45,
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >= -90,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 135,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  45
         )
         
        ) + 1,
        
        do(
         msg(
          Concat(
           Name(p(2)),
           [ is not able to detect rotation of output atom ],
           Name(p(1)),
           CR,
           [Change rotation of input atom or switch off autofit angles on reset]
          )
         ),
         -1
        ),
        
        180,
        270,
        0,
        90,    
        180,
        270,
        0,
        90
       ),
       360   {--mod--}
      ),
      3      {--round--}
     )     
    ),
    
    {--Case 17 : Bidirectional Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 18 : Other not yet defined--}
    do(
     a
    )
   ),
   {--Connected atom ist from other category--}
   do(
    {--Rotationas--}
    Round(mod(RotationAs(p(1)),360),3)
   )
  ),
 
 {--bowdlerise angle to ease case-command--}
 if(
  {--negativ angle--}
  CTUoutputatomangle < 0,
  {--adjust--}
  CTUoutputatomangle := 360 + CTUoutputatomangle
 ),
 
 {--return rotationas of input atom--}
 CTUoutputatomangle
)
], [Returns the rotationas of Atoms p(1) connected to oc p(3) of a CTU p(2). Detects straight conveyors, curved conveyors (no rotation but startangle) and CTUs (attribute IsConveyor as identifier).], [CTU_Input_Atom_Get_Rotation(out(1,c),c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Input_Atom_Get_Rotation], [Conveyors], 3, 3, [do(
 var([CTUinputatomangle],vbValue),
 var([TempInitialRotation],vbValue),

 {--get rotationas of connected input atom--}
 CTUinputatomangle :=
  if(
   Att([IsConveyor],p(1)) > 0,
   {--Connected atom is from conveyors category--}
   Case(
    {--Identifier of conveyor category--}
    Att([IsConveyor],p(1)),
    
    {--Case 1 : Advanced Non Accumulating Conveyor Straight--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 2 : Advanced Non Accumulating Conveyor Curved--}
    do(
     {--startangle + angle--}
     Round(mod((Att([startangle],p(1)) + Abs(Att([angle],p(1)))),360),3)
    ),
    
    {--Case 3 : Advanced Accumulating Conveyor Straight--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 4 : Advanced Accumulating Conveyor Curved--}
    do(
     {--startangle + angle--}
     Round(mod((Att([endangle],p(1))),360),3)
    ),
    
    {--Case 5 : Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 6 : Right Curved Accumulating Conveyor--}
    do(
     {--startangle + angle--}
     Round(mod((Att([startangle],p(1)) + Abs(Att([angle],p(1)))),360),3)
    ),
    
    {--Case 7 : Left Curved Accumulating Conveyor--}
    do(
     {--startangle - 180° + angle--}
     Round(mod((Att([startangle],p(1)) - 180 + Att([angle],p(1))),360),3)
    ),
    
    {--Case 8 : Non Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 9 : Left Curved Non Accumulating Conveyor--}
    do(
     {--startangle - 180° + angle--}
     Round(mod((Att([startangle],p(1)) - 180 + Att([angle],p(1))),360),3)
    ),
    
    {--Case 10 : Right Curved Non Accumulating Conveyor--}
    do(
     {--startangle + angle--}
     Round(mod((Att([startangle],p(1)) + Abs(Att([angle],p(1)))),360),3)
    ),
    
    {--Case 11 : Speed Changing Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 12 : Buffer Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 13 : Fast Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 14 : Fast Non Accumulating Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 15 : Turntable Unit--}
    do(
     {--Angle from table--}
     Round(mod(Cell( IcOcNo(p(3), p(2)), 2, p(1) ),360),3)
    ),
    
    {--Case 16 : Corner Transfer Unit--}
    do(
     TempInitialRotation:=
      if(Att([InitialRotation],p(2)) > 45,
       mod(Att([InitialRotation],p(2)) - 360,45)
      ),
    
     Round(
      Mod(
       {--rotationas of CTU (initialrotation) + absolute position--}
       Att([InitialRotation],p(2)) +
       
       Case(
        WhichIsTrue(
         {--x positiv 0°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 0,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 0
          ),
          
         {--x positiv 90°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 90,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 90
          ),
          
         {--x positiv 180°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 0,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 180
          ),
          
         {--x positiv 270°and no InitialRotation--}
          and(
           Att([InitialRotation],p(2)) = 0,
           Round(ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = -90,
           Round(ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1))))) = 90
          ),
        
         {--x positiv 0° + InitialRotation--}
         and(
          ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation <= 45,
          ArcSin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation >  -45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  0
         ),
         {--y negativ 90°+ InitialRotation--}
         and(
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation <= 90,
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation >  45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 135,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  45
         ),
         {--x negativ 180° + InitialRotation--}
         and(
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation <= 45,
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation >  -45,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 180,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  135
         ),
         {--y positiv 270° + InitialRotation--}
         and(
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation <= -45,
          arcsin((yAbsLoc(p(2),Model) - yAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) - TempInitialRotation >  -90,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) <= 135,
          ArcCos((xAbsLoc(p(2),Model) - xAbsLoc(p(1),Model)) / AtomDistance(p(2),(p(1)))) >  45
         )
        ) + 1,
        
        do(
         msg(
          Concat(
           Name(p(2)),
           [ is not able to detect rotation of input atom ],
           Name(p(1)),
           CR,
           [Change rotation of input atom or switch off autofit angles on reset]
          )
         ),
         -1
        ),
        
        0,
        90,
        180,
        270,
        0,
        90,
        180,
        270
       ),
       
       360    {--mod--}
      ),
      
      3       {-round---}
     )
    ),
    
    {--Case 17 : Bidirectional Conveyor--}
    do(
     {--Rotationas--}
     Round(mod(RotationAs(p(1)),360),3)
    ),
    
    {--Case 18 : Other not yet defined--}
    do(
     a
    )
   ),
   {--Connected atom ist from other category--}
   do(
    {--Rotationas--}
    Round(mod(RotationAs(p(1)),360),3)
   )
  ),
 
 {--bowdlerise angle to ease case-command--}
 if(
  {--negativ angle--}
  CTUinputatomangle < 0,
  {--adjust--}
  CTUinputatomangle := 360 + CTUinputatomangle
 ),
 
 {--return rotationas of input atom--}
 CTUinputatomangle
)
], [Returns the rotationas of Atoms p(1) connected to ic p(3) of a CTU p(2). Detects straight conveyors, curved conveyors (no rotation but startangle + angle) and CTUs (attribute IsConveyor as identifier).], [CTU_Input_Atom_Get_Rotation(in(1,c),c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Input_Atom_Set_Table], [Conveyors], 3, 3, [do(
 {--get the rotationas of every atom connected to an ic of the CTU--}
 var([CTUangle],vbValue), 
 
 {--flag for range of rotation angle--}
 var([anglecase],vbValue), 
 
 if(
  {--input atom connected ?--}
  AtomExists(p(1)),
  do(
   {--row header is the input atoms index--}
   cell(p(3), 0, p(2)):=
    Concat([ic_],String(p(3))),
   {--input atoms name--}
   cell(p(3), 1, p(2)):=
    Name(p(1)),
    
   {--get rotationas of connected atom--}
   CTUangle := 
    if(
     {--CTU detects rotationas automatically--}
     Att([AutoDetect],p(2)),
     {--Auto detect--}
     CTU_INPUT_ATOM_GET_ROTATION( p(1), p(2), p(3) ),
     {--pick existing rotationas--}
     cell(p(3), 2, p(2) )
    ),

   {--input atoms rotationas--}
   cell(p(3), 2, p(2) ):=
    CTUangle,

   {--Find area of rotation for connected atom--}
   Case(
    WhichIsTrue(
     or(CTUangle > 315, CTUangle <= 45),      {--from 315° to 45°--}
     and(CTUangle > 45, CTUangle <= 135),     {--from 45° to 135°--}
     and(CTUangle > 135, CTUangle <= 225),    {--from 135° to 225°--}
     and(CTUangle > 225, CTUangle <= 315)     {--from 225° to 315°--}
    ) + 1,
    {--set flag for area of rotation--}
    msg(Concat([Angle of ],Name(p(2)),[ can not be evaluated.])),  {--fail safe--}
    anglecase := 1,
    anglecase := 2,
    anglecase := 3,
    anglecase := 4
   ),

   {--store input atoms x_motion flag--}
   cell(p(3),3,p(2)):=
    case(anglecase,
     1,
     0,
    -1,
     0
    ),
   {--store input atoms y_motion flag--}
   cell(p(3),4,p(2)):=
    case(anglecase,
     0,
     1,
     0,
    -1
    )
  ),
  msg(Concat(Name(p(2)),[ has no atom connected to ic ],String(p(3))))   {--fail safe--}
 )
)
], [Writes rotationas and x/y motiondirectionflags of all input atoms p(1) connected to CTU p(2) into row p(3) of CTU table.
], [CTU_Input_Atom_Set_Table(in(count,c),c,count)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Output_Atom_Set_Table], [Conveyors], 3, 3, [do(
 {--get the rotationas of every atom connected to an ic of the CTU--}
 var([CTUangle],vbValue), 
 
 {--flag for range of rotation angle--}
 var([anglecase],vbValue), 
 
 if(
  {--output atom connected ?--}
  AtomExists(p(1)),
  do(
   {--row header is the input atoms index--}
   cell(p(3), 0, p(2) ):=
    Concat([oc_],String(Count)),
   {--input atoms name--}
   cell( p(3), 1, p(2) ):=
    Name(p(1)),

   {--get rotationas of connected atom--}
   CTUangle := 
    if(
     {--CTU detects rotationas automatically--}
     Att([AutoDetect],p(2)),
      {--Auto detect--}
      CTU_OUTPUT_ATOM_GET_ROTATION( p(1), p(2), p(3)),
      {--pick existing rotationas--}
      cell( p(3), 2, p(2) )
     ),

   {--input atoms rotationas--}
   cell( p(3), 2, p(2) ):=
    CTUangle,

   {--Find area of rotation for connected atom--}
   Case(
    WhichIsTrue(
     or(CTUangle > 315, CTUangle <= 45),      {--from 315° to 45°--}
     and(CTUangle > 45, CTUangle <= 135),     {--from 45° to 135°--}
     and(CTUangle > 135, CTUangle <= 225),    {--from 135° to 225°--}
     and(CTUangle > 225, CTUangle <= 315)     {--from 225° to 315°--}
    ) + 1,
    {--set flag for area of rotation--}
    msg(Concat([Angle of ],Name(p(2)),[ can not be evaluated.])),  {--fail safe--}
    anglecase := 1,
    anglecase := 2,
    anglecase := 3,
    anglecase := 4
   ),

   {--store input atoms x_motion flag--}
   cell( p(3), 3, p(2) ):=
    case(anglecase,
     1,
     0,
    -1,
     0
    ),
   {--store input atoms y_motion flag--}
   cell( p(3), 4, p(2) ):=
    case(anglecase,
     0,
     1,
     0,
    -1
    )
  ),
  msg(Concat(Name(p(2)),[ has no atom connected to oc ],String(Count)))   {--fail safe--}
 )
)
], [Writes rotationas and x/y motiondirectionflags of all output atoms p(1) connected to CTU p(2) into row p(3) of CTU table.
], [CTU_Output_Atom_Set_Table(out(count + nric(c),c),count)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_IsCTU], [Conveyors], 1, 1, [do(
 if(
  Att([IsConveyor],p(1)) = 16,
  True,
  False
 )
)
], [detects wheter an atom is a CTU
], [CTU_IsCTU(in(1,c))], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Change_Product_Z_Rotation], [Conveyors], 2, 2, [do(
 {--rotationas of current output atom--}
 var([outputangle],vbValue),
 
 {--rotationas of current output atom--}
 outputangle := Cell(Att([CurOC],p(1)) + NrIC(p(1)),2,p(1),1),

 {--Change of product rotationas depends on rotationas of output atom--}
 case(
  WhichIsTrue(
   {--range from 315° to 45°--}
   or(outputangle > 315, outputangle <= 45),
   {--range from 45° to 135°--}
   and(outputangle > 45, outputangle <= 135),
   {--range from 135° to 225°--}
   and(outputangle > 135, outputangle <= 225),
   {--range from 225° to 315°--}
   and(outputangle > 225, outputangle <= 315)
  ),
  {--adjust rotationas of product--}
  - 0,
  - 90,
  - 180,
  - 270
 )
)
], [Calculates the change of rotationas for product p(2) caused by CTU p(1).
], [CTU_Change_Product_Z_Rotation(c,i)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Detect_Collision], [Conveyors], 1, 1, [do(
 {--rotationas of current input atom of CTU--}
 var(
  [Input_Atom_Rotation],
  vbValue,
  Round(Cell(Att([CurIC],p(1)),2,p(1),1))
 ),
 {--rotationas of current output atom of CTU--}
 var(
  [Output_Atom_Rotation],
  vbValue,
  Round(Cell(Att([CurOC],p(1)) + NrIC(p(1)),2,p(1),1))
 ),
 {--rotationas of output atom connected to current output channel of CTU--}
 var(
  [Output_Output_Atom_Rotation],
  vbValue,
  Round(Cell(Att([CurOC],Out(Att([CurOC],p(1)),p(1))) + NrIC(Out(Att([CurOC],p(1)),p(1))),2,Out(Att([CurOC],p(1)),p(1)),1))
 ),
 {--rotationas of output atom connected to current input channel of CTU--}
 var(
  [Input_Output_Atom_Rotation],
  vbValue,
  Round(Cell(Att([CurOC],In(Att([CurIC],p(1)),p(1))) + NrIC(In(Att([CurIC],p(1)),p(1))),2,In(Att([CurIC],p(1)),p(1)),1))
 ),
 
 WhichIsTrue(
 
  {--no collission with empty output atom--}
  Content(Out(Att([CurOC],p(1)),p(1))) <= 0,
 
  {--no turn (straight ahead) and no placing without input movement--}
  and(
   {--input movement enabled--}
   not(Att([MoveInFlag],p(1))),
   {--straight ahead--}
   Output_Atom_Rotation = Input_Atom_Rotation
  ),
  
  {--CTU requires extra treatment, as it has no rotationas--}
  Or(
   And(
    {--input movement enabled--}
    not(Att([MoveInFlag],p(1))),
    
    if(CTU_IsCTU(Out(Att([CurOC],p(1)),p(1))),   {--CTU following--}
     {--no turn causes collision--}
     and(
      Abs(Output_Atom_Rotation - Output_Output_Atom_Rotation) <> 90,
      Abs(Output_Atom_Rotation - Output_Output_Atom_Rotation) <> 270
     )
    ),
    
    if(CTU_IsCTU(In(Att([CurIC],p(1)),p(1))),   {--CTU in front--}
     {--no turn causes collision--}
     and(
      Abs(Output_Atom_Rotation - Input_Output_Atom_Rotation) <> 90,
      Abs(Output_Atom_Rotation - Input_Output_Atom_Rotation) <> 270
     )
    )
   ),
  {--output movement has finished, no delay necessary to prevent collissions--}
  Time - Att([ExitTime],p(1)) >= TravelTime(Att([Speed],Out(Att([CurOC],p(1)),p(1))),xSize(vtp(Att([CTUAtom],p(1)))))
  )
 
 {--true or false--}
 ) > 0
)
], [Check whether following product inside CTU p(1) has to wait in order to prevent collissions with previous product.], [CTU_Detect_Collision(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Change_Passing_Atom_Drawing], [Conveyors], 1, 1, [  do(
   {--Set Flag for changed graphic code (CTU passing atoms only)--}
   {--Prevent changing 2D and 3D code at every following CTU--}
   Ddb([DrawFlag],p(1)) := 1,
   Ddb([DrawXsize],p(1)) := xSize(p(1)),
   Ddb([DrawYsize],p(1)) := ySize(p(1)),
      
   {--adding rotation functionality to 3D eventhandler of entered atom--}
   On3DDraw(p(1)) :=
    Concat(
     [do(],

     CR,
     Tab,
     [{--Atom origin for testing purpose--}],       
     CR,     
     Tab,
     [di3DBox(0, 0, 0, 0.1, 0.1, zSize * 2, Colorblack),di3DBox(0, 0, 0, xSize, ySize, zSize/2, Color),],
     CR,     

     CR,
     Tab,
     [{--Corner Transfer Unit added variables for rotationas in order to compensate change of transportation direction--}],
     CR,
     Tab,
     [RotateCoords(Ddb([DrawRotationas],c),0,0,1,0,0,0),],
     CR,

     CR,
     Tab,
     [{--Corner Transfer Unit added variables for translation in order to compensate change of transportation direction--}],
     CR,
     Tab,
     [TranslateCoords(Ddb([DrawXtranslate],c),Ddb([DrawYtranslate],c),0),],
     CR,

 
     CR,     
     Tab,
     [{--Corner Transfer Unit replaced xsize and ysize by 2 variables in order to compensate change of transportation direction--}],
     CR,
     Tab,
     do(
      var([Product3DDrawing],vbString,On3DDraw(m(p(1)))),
      Product3DDrawing:=
       StringReplace(
        Product3DDrawing,
        [xsize],
        [c.DrawXsize],
        SR_IGNORE_CASE + SR_REPLACE_ALL
       ),
      Product3DDrawing:=
       StringReplace(
        Product3DDrawing,
        [ysize],
        [c.DrawYsize],
        SR_IGNORE_CASE + SR_REPLACE_ALL
       ),
      Product3DDrawing
     ), 
         
     CR,
     [)]
    ),


    
   {--prepare 2D-Draw for rotated drawing of icon and 2D-commands--}
   SetSetting(sa2DDraw,1,p(1)),
   SetSetting(saRotate2d,1,p(1)),
   SetSetting(saIcon,0,p(1))
  )
], [Change 2D-Draw and 3D-Draw Eventhandler of atoms p(1) entering a CTU. Necessary as the standard atoms do not have a variable to store rotation changes. Indeed this makes the CTU a slow atom, but changing code of the product/container is full of risk for backward compatibility and speed too.
], [CTU_Change_Passing_Atom_Drawing(i)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Set_Product_Location], [Conveyors], 2, 2, [do(
 
 {--calculate x_location of product before starting the input movement--}
 xLoc(p(2)) :=
  {--position depends on angle and position of connected input atom--}
  Case(2 + Cell(Att([CurIC],p(1)),3,p(1),1),
   {--case 1 : movement into positiv x direction--}
   xSize(p(1)),
   {--case 2 : no movement into x direction--}
   0,
   {--case 3 : movement into negativ x direction--}
   0 - xSize(p(2))
  ),
  
 {--calculate y_location of product before starting the input movement--}
 yLoc(p(2)) :=
  {--position depends on angle and position of connected input atom--}
  Case(2 + Cell(Att([CurIC],p(1)),4,p(1),1),
   {--case 1 : movement into positiv y direction--}
   ySize(p(1)),
   {--case 2 : no movement into x direction--}
   0,
   {--case 3 : movement into negativ y direction--}
   0 - ySize(p(2))
  ),
 
 {--transport high is zsize of CTU--}
 zLoc(p(2)) := zSize(p(1))
 
)
], [Calculates location of product p(2) inside CTU p(1) before starting the input movement.], [CTU_Set_Product_Location(c,i)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Detect_Transfer_Time], [Conveyors], 1, 1, [if(
 {--turn or straight ahead ?--}
 Round(Cell(Att([CurOC],p(1)) + NrIC(p(1)),2,p(1),1)) = Round(Cell(Att([CurIC],p(1)),2,p(1),1)),
 {--straight--}
 False,
 {--turn--}
 True
)
], [Check whether the CTU p(1) has to deal a transfer time in order to execute the turn of direction for current product.], [CTU_Detect_Transfer_Time(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Detect_Transport_Length], [Conveyors], 1, 1, [do(
 var([xsize_or_ysize],vbValue),
 
 xsize_or_ysize :=
  Case(
   WhichIsTrue(
    Cell(Att([CurIC],p(1)),3,p(1),1) <> 0,
    Cell(Att([CurIC],p(1)),4,p(1),1) <> 0
   ),
   xSize(p(1)),
   ySize(p(1))
  ),

 xsize_or_ysize
)
], [Returns the lengt taken from xsize or ysize of the CTU depending on Transport direction 
], [CTU_Detect_Transport_Length(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Change_Product_XY_Size], [Conveyors], 2, 2, [do(
 {--rotationas of current output atom--}
 var([anglediff],vbValue),
 
 {--Flag if turn is true--}
 var([turnflag],vbValue),
 
 {--temp. xsize and ysize--}
 var([temp_x],vbValue),
 var([temp_y],vbValue),
 
 {--diffrence between--}
 anglediff := 
 {--outputangle and--}
  Cell(Att([CurOC],p(1)) + NrIC(p(1)),2,p(1),1) - 
  {--inputangle--}
  Cell(Att([CurIC],p(1)),2,p(1),1),
  
 {--set flag if turn left or right--}
 turnflag := Abs(Mod(anglediff,180)) <> 0,

 if(
  {--turn left or right is true--}
  turnflag,
  do(
   {--storing temp. xsize and ysize--}
   temp_x := xSize(p(2)),
   temp_y := ySize(p(2)),
   {--changing x and y sizes in order to keep conveyors doing the correct setloc OnEntered of conveyor etc.--} 
   xSize(p(2)) := temp_y,
   ySize(p(2)) := temp_x,
   {--changing variables for drawing too if angle singnals turn--}
   Case(
    WhichIsTrue(
     Ddb([DrawRotationas],p(2)) = 0,
     Ddb([DrawRotationas],p(2)) = 90,
     Ddb([DrawRotationas],p(2)) = 180,
     Ddb([DrawRotationas],p(2)) = 270
    ),
    {--0°--}
    do(
     a
    ),
    {--90°--}
    do(
     Ddb([DrawXsize],p(2)) := ySize(p(2)),
     Ddb([DrawYsize],p(2)) := xSize(p(2))
    ),
    {--180°--}
    do(
     a
    ),
    {--270°--}
    do(
     Ddb([DrawXsize],p(2)) := ySize(p(2)),
     Ddb([DrawYsize],p(2)) := xSize(p(2))
    )
   )
  )
 )
)
], [On turn (left or right) a change of xsize and ysize is required in order to keep conveyors working correct
], [CTU_Change_Product_XY_Size(c,i)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Change_Product_Translation_On_Entered], [Conveyors], 2, 2, [do(
 var([tempatom],vbAtom,p(2)), 
 
 Case(
  WhichIsTrue(
   {--Case 1 : Input from 0°--}
   and(
    Cell(Att([CurIC],p(1)),3,p(1),1) = 1,
    Cell(Att([CurIC],p(1)),4,p(1),1) = 0
   ),
   {--Case 2 : Input from 90°--}
   and(
    Cell(Att([CurIC],p(1)),3,p(1),1) = 0,
    Cell(Att([CurIC],p(1)),4,p(1),1) = 1
   ),
   {--Case 3 : Input from 180°--}
   and(
    Cell(Att([CurIC],p(1)),3,p(1),1) = -1,
    Cell(Att([CurIC],p(1)),4,p(1),1) = 0
   ),
   {--Case 4 : Input from 270°--}
   and(
    Cell(Att([CurIC],p(1)),3,p(1),1) = 0,
    Cell(Att([CurIC],p(1)),4,p(1),1) = -1
   )
  ),

  {--Execute Case 1 : Input from 0°--}
  Case(
   WhichIsTrue(
    Ddb([DrawRotationas],tempatom) = 0,
    Ddb([DrawRotationas],tempatom) = 90,
    Ddb([DrawRotationas],tempatom) = 180,
    Ddb([DrawRotationas],tempatom) = 270
   ),
   {--SubCase 1 : drawing rotation of 0°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := 0
   ),
   {--SubCase 2 : drawing rotation of 90° *--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 3 : drawing rotation of 180°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 4 : drawing rotation of 270°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0
   )
  ),
  
  {--Execute Case 2 : Input from 90°--}
  Case(
   WhichIsTrue(
    Ddb([DrawRotationas],tempatom) = 0,
    Ddb([DrawRotationas],tempatom) = 90,
    Ddb([DrawRotationas],tempatom) = 180,
    Ddb([DrawRotationas],tempatom) = 270
   ),
   {--SubCase 1 : drawing rotation of 0° *--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := Ddb([DrawXsize],tempatom) - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 2 : drawing rotation of 90°--}
   do(
    Ddb([DrawXtranslate],tempatom) := Ddb([DrawYsize],tempatom) - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 3 : drawing rotation of 180° *--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom)
   ),
   {--SubCase 4 : drawing rotation of 270° --}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0
   )
  ),
  
  {--Execute Case 3 : Input from 180°--}
  Case(
   WhichIsTrue(
    Ddb([DrawRotationas],tempatom) = 0,
    Ddb([DrawRotationas],tempatom) = 90,
    Ddb([DrawRotationas],tempatom) = 180,
    Ddb([DrawRotationas],tempatom) = 270
   ),
   {--SubCase 1 : drawing rotation of 0°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := 0
   ),
   {--SubCase 2 : drawing rotation of 90° *--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 3 : drawing rotation of 180°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 4 : drawing rotation of 270°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0
   )
  ),
  {--Execute Case 4 : Input from 270°--}
  Case(
   WhichIsTrue(
    Ddb([DrawRotationas],tempatom) = 0,
    Ddb([DrawRotationas],tempatom) = 90,
    Ddb([DrawRotationas],tempatom) = 180,
    Ddb([DrawRotationas],tempatom) = 270
   ),
   {--SubCase 1 : drawing rotation of 0°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := 0
   ),
   {--SubCase 2 : drawing rotation of 90° *--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0,
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 3 : drawing rotation of 180°--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
   ),
   {--SubCase 4 : drawing rotation of 270° *--}
   do(
    Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
    Ddb([DrawYtranslate],tempatom) := 0
   )
  )
   
 )
)
], [Calculates the change of translation OnEntered of CTU p(1) for product p(2).], [CTU_Change_Product_Translation_On_Entered(c,i)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Adjust_Product_Rotation_As], [Conveyors], 1, 1, [do(
 var([tempangle],vbValue,p(1)),
 
 if(
  {--More than 360° or equal to 360°--}
  Abs(tempangle) >= 360,
  {--adjust to range from -360° to 360°--}
  tempangle := Mod(tempangle, 360)
 ),
 
 if(
  {--negativ angle--}
  tempangle < 0,
  {--adjust to positive angle--}
  tempangle := 360 + tempangle
 ),
  
 tempangle
)
], [Adjust angles stored in variable p(1) larger than 360° or lower than 0°], [CTU_Adjust_Product_Rotation_As(Ddb([DrawRotationas],i))], 0, [Corner Transfer Unit]);
DefineFunction([CTU_Change_Product_Translation_On_Exited], [Conveyors], 1, 1, [do(
 var([tempatom],vbAtom,p(1)), 

 Case(
  WhichIsTrue(
   Ddb([DrawRotationas],tempatom) = 0,
   Ddb([DrawRotationas],tempatom) = 90,
   Ddb([DrawRotationas],tempatom) = 180,
   Ddb([DrawRotationas],tempatom) = 270
  ),
  {--0°--}
  do(
   Ddb([DrawXtranslate],tempatom) := 0,
   Ddb([DrawYtranslate],tempatom) := 0
  ),
  {--90°--}
  do(
   Ddb([DrawXtranslate],tempatom) := 0,
   Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
  ),
  {--180°--}
  do(
   Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
   Ddb([DrawYtranslate],tempatom) := 0 - Ddb([DrawYsize],tempatom)
  ),
  {--270°--}
  do(
   Ddb([DrawXtranslate],tempatom) := 0 - Ddb([DrawXsize],tempatom),
   Ddb([DrawYtranslate],tempatom) := 0
  )
 )
)
], [Calculates the change of translation OnExited for product p(1).], [CTU_Change_Product_Translation_On_Exited(i)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_3Ddraw_ctu_without_icon], [Conveyors], 1, 1, [{--CTU with icon--}
do(
 {--Legs--}
 if(
  Att([DrawLegs],p(1)),
  do(
   {--Legs--}
   di3DBox(-0.05, 0, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   di3DBox(-0.05, ySize(p(1)) - 0.05, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   di3DBox(xSize(p(1)), 0, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   di3DBox(xSize(p(1)), ySize(p(1)) - 0.05, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   
   {--Leg supports--}
   If(zSize(p(1)) > 0.3,
    do(
     di3DBox(-0.05, 0.05, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.1, 0.03, Color(p(1)), 0),
     di3DBox(xSize(p(1)), 0.05, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.1, 0.03, Color(p(1)), 0),
     di3DBox(0, 0, zSize(p(1)) - 0.3, xSize(p(1)), 0.03, 0.03, Color(p(1)), 0),
     di3DBox(0, ySize(p(1)) - 0.05, zSize(p(1)) - 0.3, xSize(p(1)), 0.03, 0.03, Color(p(1)), 0)
    )
   )
  )
 ),

 {--Plate without icon--}
 di3DBox(0, 0.05, zSize(p(1))-0.11, xSize(p(1)), ySize(p(1))-0.1, 0.1, color(p(1)))
)
], [Draws a Corner Transfer Unit p(1) without icon on the plate
], [CTU_3Ddraw_ctu_without_icon(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_3Ddraw_ctu_with_icon], [Conveyors], 1, 1, [{--CTU with icon--}
do(
 {--Legs--}
 if(
  Att([DrawLegs],p(1)),
  do(
   {--legs--}
   di3DBox(-0.05, 0, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   di3DBox(-0.05, ySize(p(1)) - 0.05, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   di3DBox(xSize(p(1)), 0, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   di3DBox(xSize(p(1)), ySize(p(1)) - 0.05, zSize(p(1)) - Att([LegExtend],p(1)), 0.05, 0.05, zSize(p(1)), ColorSilver, 0),
   
   {--Leg supports--}
   If(zSize(p(1)) > 0.3,
    do(
     di3DBox(-0.05, 0.05, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.1, 0.03, Color(p(1)), 0),
     di3DBox(xSize(p(1)), 0.05, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.1, 0.03, Color(p(1)), 0),
     di3DBox(0, 0, zSize(p(1)) - 0.3, xSize(p(1)), 0.03, 0.03, Color(p(1)), 0),
     di3DBox(0, ySize(p(1)) - 0.05, zSize(p(1)) - 0.3, xSize(p(1)), 0.03, 0.03, Color(p(1)), 0)
    )
   )
  )
 ),

 {--Plate with icon--}
 SetMaterialTexture(IconToTexture(Icon)),
 ScaleTextureCoords(Round(xSize(p(1))*2), Round(ySize(p(1))*2)),
 SetMaterialColor(Color, EMISSIVE_COLOR),
 di3DBox(0, 0.05, zSize(p(1))-0.11, xSize(p(1)), ySize(p(1))-0.1, 0.1, color(p(1)))
)
], [Draws a Corner Transfer Unit p(1) with icon on the plate
], [CTU_3Ddraw_ctu_with_icon(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_2Ddraw_direction_arrows], [Conveyors], 1, 1, [do(
 var([arrowlength], vbValue, Min(xSize(p(1))/2, ySize(p(1))/2)),
 
 {--Text has same rotation as CTU--}
 RotateCoords(Att([InitialRotation],p(1)), 0, 0, 1),

 {--Input arrows--}
 Repeat(
  NrIC(p(1)),
  do(
   PushCoords,
   {--Rotate according to input direction--}
   RotateCoords(
    Cell(Count, 2,  p(1), 1) - Att([InitialRotation],p(1)),
    0, 0, 1,
    xSize/2,
    ySize/2
   ),
   DrawArrow(
    xSize(p(1))/2 - arrowlength, 
    ySize(p(1))/2, 
    xSize(p(1))/2, 
    ySize(c)/2, 
    0, 
    0, 
    ColorWhite, 
    True, 
    100, 
    0
   ),
   PopCoords
  )
 ),
 
 {--Output arrows--}
 Repeat(
  NrOC(p(1)),
  do(
   PushCoords,
   {--Rotate according to output direction--}
   RotateCoords(
    Cell(nRows(p(1)) + 1 - Count, 2,  c, 1) - Att([InitialRotation],p(1)),
    0, 0, 1,
    xSize/2,
    ySize/2
   ),
   DrawArrow(
    xSize(p(1))/2, 
    ySize(p(1))/2, 
    xSize(p(1))/2 + arrowlength, 
    ySize(p(1))/2, 
    0.15, 
    0.15, 
    ColorWhite, 
    True, 
    100, 
    0
   ),
   PopCoords
  )
 )
)
], [Draws arrows for p(1) according to rotation of atom connected to input and output channels
], [CTU_2Ddraw_direction_arrows(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_3Ddraw_ctu_chain_conveyor_animated], [Various], 1, 1, [{--chain conveyor--}
do(
 { side supports }
 di3DBox(0.08, 0, zSize(p(1)) - 0.18, xSize(p(1)) - 0.16, 0.12, 0.16, Color(p(1))),
 di3DBox(0.08, ySize(p(1)) - 0.12, zSize(p(1)) - 0.18, xSize(p(1)) - 0.16, 0.12, 0.16, Color(p(1))),
 
 { leg supports }
 di3DBox(0.1, 0.035, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(0.1, ySize(p(1)) - 0.085, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(0.1, 0.085, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.17, 0.03, ColorSilver),
 
 di3DBox(xSize(p(1)) - 0.2, 0.035, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(xSize(p(1)) - 0.2, ySize(p(1)) - 0.085, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(xSize(p(1)) - 0.2, 0.085, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.17, 0.03, ColorSilver),
 
 { outer conveyor chain }

 DrawCylinder(0.08, 0.06, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, 0.06, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),

 di3DBox(0.1, 0.05, zSize(p(1)) - 0.15, 0.12, ySize(p(1)) - 0.1, 0.05, ColorSilver),
 di3DBox(xSize(p(1)) - 0.22, 0.05, zSize(p(1)) - 0.15, 0.12, ySize(p(1)) - 0.1, 0.05, ColorSilver),

 di3DBox(0.08, 0.03, zSize(p(1)) - 0.02, xSize(p(1)) - 0.16, 0.06, 0.02, ColorBlack),
 di3DBox(0.08, ySize(p(1)) - 0.09, zSize(p(1)) - 0.02, xSize(p(1)) - 0.16, 0.06, 0.02, ColorBlack),

 DrawCylinder(0.08, 0.06, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, 0.06, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),

 { inner conveyor chain }
 
 PushCoords,
 
 if(ySize(p(1)) < xSize(p(1)),
  Do(
   RotateCoords(90, 0, 0, 1, 0, xSize(p(1)) / (xSize(p(1)) / ySize(p(1))) - ySize(p(1))),
   TranslateCoords(0, 0 - xSize(p(1)), if(Content(p(1)) > 0, zloc(First(p(1))) - zSize(p(1)), 0))  
  ),
  Do(
   RotateCoords(90, 0, 0, 1, xSize(p(1)) / (xSize(p(1)) / ySize(p(1))) - ySize(p(1)), 0),
   TranslateCoords(0, 0 - xSize(p(1)), if(Content(p(1)) > 0, zloc(First(p(1))) - zSize(p(1)), 0))  
  )
 ),
  
 di3DBox(0.24, 0.25, zSize(p(1)) - 0.14, ySize(p(1)) - 0.48, xSize(p(1)) - 0.5, 0.08, ColorSilver),
 
 di3DBox(0.24, 0.24, zSize(p(1)) - 0.18, ySize(p(1)) - 0.48, 0.12, 0.16, Color(p(1))),
 di3DBox(0.24, xSize(p(1)) - 0.36, zSize(p(1)) - 0.18, ySize(p(1)) - 0.48, 0.12, 0.16, Color(p(1))),
 
 di3DBox(0,0,0,0,0,0,ColorSilver),
 
 DrawCylinder(0.24, 0.3, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, 0.3, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 
 di3DBox(0.24, 0.27, zSize(p(1)) - 0.02, ySize(p(1)) - 0.48, 0.06, 0.02, ColorBlack),
 di3DBox(0.24, xSize(p(1)) - 0.33, zSize(p(1)) - 0.02, ySize(p(1)) - 0.48, 0.06, 0.02, ColorBlack),

 DrawCylinder(0.24, 0.3, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, 0.3, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 
 PopCoords
 
)
], [Draws a Corner Transfer Unit p(1) with animated chain conveyors
], [CTU_3Ddraw_ctu_chain_conveyor_animated(c)], 0, [Corner Transfer Unit]);
DefineFunction([CTU_3Ddraw_ctu_chain_conveyor], [Various], 1, 1, [{--chain conveyor--}
do(
 { side supports }
 di3DBox(0.08, 0, zSize(p(1)) - 0.18, xSize(p(1)) - 0.16, 0.12, 0.16, Color(p(1))),
 di3DBox(0.08, ySize(p(1)) - 0.12, zSize(p(1)) - 0.18, xSize(p(1)) - 0.16, 0.12, 0.16, Color(p(1))),
 
 { leg supports }
 di3DBox(0.1, 0.035, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(0.1, ySize(p(1)) - 0.085, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(0.1, 0.085, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.17, 0.03, ColorSilver),
 
 di3DBox(xSize(p(1)) - 0.2, 0.035, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(xSize(p(1)) - 0.2, ySize(p(1)) - 0.085, 0, 0.05, 0.05, zSize(p(1)) - 0.1, ColorSilver),
 di3DBox(xSize(p(1)) - 0.2, 0.085, zSize(p(1)) - 0.3, 0.03, ySize(p(1)) - 0.17, 0.03, ColorSilver),
 
 { outer conveyor chain }

 DrawCylinder(0.08, 0.06, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, 0.06, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),

 di3DBox(0.1, 0.05, zSize(p(1)) - 0.15, 0.12, ySize(p(1)) - 0.1, 0.05, ColorSilver),
 di3DBox(xSize(p(1)) - 0.22, 0.05, zSize(p(1)) - 0.15, 0.12, ySize(p(1)) - 0.1, 0.05, ColorSilver),

 di3DBox(0.08, 0.03, zSize(p(1)) - 0.02, xSize(p(1)) - 0.16, 0.06, 0.02, ColorBlack),
 di3DBox(0.08, ySize(p(1)) - 0.09, zSize(p(1)) - 0.02, xSize(p(1)) - 0.16, 0.06, 0.02, ColorBlack),

 DrawCylinder(0.08, 0.06, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, 0.06, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(xSize(p(1)) - 0.08, ySize(p(1)) - 0.06, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),

 { inner conveyor chain }
 
 PushCoords,
 
 if(ySize(p(1)) < xSize(p(1)),
  Do(
   RotateCoords(90, 0, 0, 1, 0, xSize(p(1)) / (xSize(p(1)) / ySize(p(1))) - ySize(p(1))),
   TranslateCoords(0, 0 - xSize(p(1)), 0)  
  ),
  Do(
   RotateCoords(90, 0, 0, 1, xSize(p(1)) / (xSize(p(1)) / ySize(p(1))) - ySize(p(1)), 0),
   TranslateCoords(0, 0 - xSize(p(1)), 0)  
  )
 ),
  
 di3DBox(0.24, 0.25, zSize(p(1)) - 0.14, ySize(p(1)) - 0.48, xSize(p(1)) - 0.5, 0.08, ColorSilver),
 
 di3DBox(0.24, 0.24, zSize(p(1)) - 0.18, ySize(p(1)) - 0.48, 0.12, 0.16, Color(p(1))),
 di3DBox(0.24, xSize(p(1)) - 0.36, zSize(p(1)) - 0.18, ySize(p(1)) - 0.48, 0.12, 0.16, Color(p(1))),
 
 di3DBox(0,0,0,0,0,0,ColorSilver),
 
 DrawCylinder(0.24, 0.3, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.12, -0.06, -0.06, -180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, 0.3, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.12, 0.06, 0.06, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 
 di3DBox(0.24, 0.27, zSize(p(1)) - 0.02, ySize(p(1)) - 0.48, 0.06, 0.02, ColorBlack),
 di3DBox(0.24, xSize(p(1)) - 0.33, zSize(p(1)) - 0.02, ySize(p(1)) - 0.48, 0.06, 0.02, ColorBlack),

 DrawCylinder(0.24, 0.3, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.06, -0.08, -0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, 0.3, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 DrawCylinder(ySize(p(1)) - 0.24, xSize(p(1)) - 0.3, zSize(p(1)) - 0.08, 0.06, 0.08, 0.08, 180, Y_AXIS, CP_SIDES + CP_TOP + CP_BOTTOM),
 
 PopCoords
 
)
], [Draws a Corner Transfer Unit p(1) with chain conveyors
], [CTU_3Ddraw_ctu_chain_conveyor(c)], 0, [Corner Transfer Unit]);
Set(Icon(a), 
 RegisterIcon(TexturesDir([tech\etopcromegunside2sml.jpg]), [etopcromegunside2sml.jpg], 1, 0, 0, 255, 255, false, 0));
SetMaterial(
 RegisterMaterial([Default], 8421504, 8421504, 3289650, 0, 0.100000001490116, 0, false, false, 1, 0), 1, a);
AddTexture(
 RegisterTexture(TexturesDir([tech\etopcromegunside2sml.jpg]), [etopcromegunside2sml.jpg], 256, 256, 1, 1, 0, 0, 0, 0), a);
Set(Version(a), 7.3);
SetTreeIcon(pDir([Media\Icons\Corner Transfer Unit.ico]));
Set(Info, [
Last revision:
-------------------
July, 2008, CM
]);
SetChannels(1, 1);
SetChannelRanges(1, 3, 1, 3);
int001(71);
SetSize(1, 1, 1);
LockPosition(false);
LockSize(false);
DisableIconRotation(false);
SetProductCode([]);
CreateAttributes(26);
SetAttributeName(r(1), [InStrategy]);
SetAttributeName(r(2), [SendTo]);
SetAttributeName(r(3), [EntryTrigger]);
SetAttributeName(r(4), [ExitTrigger]);
SetAttributeName(r(5), [CurIC]);
SetAttributeName(r(6), [CurOC]);
SetAttributeName(r(7), [Speed]);
SetAttributeName(r(8), [TransferTime]);
SetAttributeName(r(9), [CurTransferTime]);
SetAttributeName(r(10), [InitialRotation]);
SetAttributeName(r(11), [DrawLegs]);
SetAttributeName(r(12), [TransferAnimate]);
SetAttributeName(r(13), [StraightFlag]);
SetAttributeName(r(14), [CTUAtom]);
SetAttributeName(r(15), [LibCat]);
SetAttributeName(r(16), [LibSubCat]);
SetAttributeName(r(17), [IsConveyor]);
SetAttributeName(r(18), [ExitTime]);
SetAttributeName(r(19), [TransferTimeFlag]);
SetAttributeName(r(20), [TransferTimeAhead]);
SetAttributeName(r(21), [MoveInFlag]);
SetAttributeName(r(22), [Icon3D]);
SetAttributeName(r(23), [AutoDetect]);
SetAttributeName(r(24), [LegExtend]);
SetAttributeName(r(25), [ModifyProduct2D]);
SetAttributeName(r(26), [ResetTrigger]);
SetExprAtt(r(1), [{.openallic(c)|1. Any inputchannel.}openallic(c)]);
SetExprAtt(r(2), [1]);
SetExprAtt(r(7), [1]);
SetExprAtt(r(8), [0]);
SetExprAtt(r(9), [0]);
SetExprAtt(r(11), [1]);
SetExprAtt(r(12), [1]);
SetExprAtt(r(14), [1]);
SetExprAtt(r(17), [16]);
SetExprAtt(r(21), [0]);
SetExprAtt(r(22), [4]);
SetExprAtt(r(23), [1]);
SetExprAtt(r(24), [zSize(c)]);
int024;
SetTable(1, 4);
int015(0, 0, [`channel`
1
]);
int015(1, 0, [`atomname`
]);
int015(2, 0, [`rotationas`
]);
int015(3, 0, [`x_motionflag`
]);
int015(4, 0, [`y_motionflag`
]);
Set(OnEvent, [Case(
 EventCode,

 {--Event 1: input strategy--}
 Do(
  {--status empty--}
  Status(c) := 13,
  
  {--input strategy--}
  InStrategy
 ),
 
 {--Event 2: stop input movement, select oc and start transfer time--}
 do(
  {--stop input movement--}
  StopAtom(i), 
 
  {--select and store output channel--}
  CurOC := SendTo,
  
  {--turn or straight ahead ?--}
  TransferTimeFlag := 
   Max(
    {--straight ahead also requires Transfertime--}
    TransferTimeAhead, 
    {--TransferTime only on turn left/right--}
    CTU_Detect_Transfer_Time(c)
   ),
   
  {--calculate current transfer time--}
  CurTransferTime := 
   if(TransferTimeFlag, {--TransferTime necessary ?--}
    TransferTime,       {--TransferTime--}
    0                   {--no TransferTime --}
   ),
  
  {--animate TransferTime (optional)--}
  if(
   and(
    TransferAnimate,    {--animation--}
    CurTransferTime > 0 {--fail safe--}
   ),
   do(
    {--set product speed for part 1 of animation--}
    SetSpeed(
     0,
     0,
     0.1/CurTransferTime/2, {--0.1 m elevation--}
     i
    ),

    {--execute current transfer time (animated)--}
    CreateEvent(0, c, 3, 0, i)
   ),
   do(
    {--simply execute current transfer time--}
    CreateEvent(CurTransferTime, c, 5, 0, i)
   )
  )
  
 ),
 
 {--Event 3: execute part 1 of current transfer time (animated)--}
 do(  
  {--set product speed for part 1 of animation--}
  SetSpeed(
   0,
   0,
   0.1/CurTransferTime/2, {--0.1 m elevation up--}
   i
  ), 
 
  {--execute part 2 of current transfer time (animated)--}
  CreateEvent(CurTransferTime/2, c, 4, 0, i)
 ),

 {--Event 4: execute part 2 of current transfer time (animated)--}
 do(
  {--stop animation--}
  StopAtom(i),  
 
  {--set product speed for part 1 of animation--}
  SetSpeed(
   0,
   0,
   0 - 0.1/CurTransferTime/2, {--0.1 m elevation down--}
   i
  ), 
 
  {--execute part 2 of current transfer time (animated)--}
  CreateEvent(CurTransferTime/2, c, 5, 0, i)
 ),
 
 {--Event 5: stop part 2 of current transfer time (animated)--}
 do(
  {--stop animation--}
  StopAtom(i),
  
  {--send on the product--}
  CreateEvent(0, c, 6, 0, i)
 ),

 {--Event 6: send on the product--}
 Do(
  {--status blocked--}
  Status(c) := 5,
  
  {--ocready--}
  OpenOc(CurOC, c)
 ),
 
 {--Event 7: open input when product has left collision area--}
 do(
  {--permission to enter without checking after collision time--}
  c.CheckFlag := 0,
  
  {--open stored ic to permit entrance of next product--}
  OpenIC(CurIC, c)
 )
)
]);
Set(OnEntered, [Do(
 {--close all ic--}
 CloseAllIc(c),
 
 {--store input channel (necessary only for first product after Reset)--}
 CurIC:= ic(c),
 
 {--Used in OnIcReady to check for next input atom--}
 c.CheckFlag := 1,
 
 {--status conveying--}
 Status(c) := 26,
 
 {--store atom (used in IcReady in order to get its xsize)--}
 CTUAtom := i,
 
 {--rotationas of current input atom--}
 var([inputangle], vbValue),

 {--diffrence of rotationas between CTU and current input atom--}
 var([inputanglediff], vbValue),
 
 {--rotationas of current input atom--}
 inputangle := Cell(CurIC, 2, c, 1),
  
 {--diffrence of rotationas between CTU and input atom--}
 inputanglediff := mod(Round(InitialRotation - inputangle,3), 360),

 {--bowdlerised diffrence of rotationas between CTU and input atom--}
 if(
  {--positiv angle--}
  inputanglediff > 0,
  {--adjust--}
  inputanglediff := inputanglediff - 360
 ),
   
 {--compensate diffrence of rotationas between CTU and input atom--}
 Ddb([DrawRotationas], i) := Ddb([DrawRotationas], i) - inputanglediff,
 
 {--bowdlerised rotation of input atom--}
 Ddb([DrawRotationas], i) := CTU_Adjust_Product_Rotation_As(Ddb([DrawRotationas], i)),

 {--Normally conveyors turn products into transport direction.--}
 {--Using a CTU this characteristics is undesired--}
 
 if(
  {--Product/Container first passing a CTU ?--}
  not(Ddb([DrawFlag], i)),
  
  do(
   {--Set flag to change behavior of 2D and 3D Eventhandler.--}
   Ddb([DrawFlag], i) := 1,
   
   {--First setting of drawing variables--}
   Ddb([DrawXsize],i) := xSize(i),
   Ddb([DrawYsize],i) := ySize(i),
   
   if(
    {--Modify default 2D visualization of Product in order to display the detailed rotation behaviour--}
    ModifyProduct2D,
    do(
     {--Enable 2DDraw--}
     SetSetting(sa2DDraw, 1, i),
     SetSetting(saRotate2d, 1, i),
     {--Disable Icon--}
     SetSetting(saIcon, 0, i),
     {--Disable 2DOutline--}
     SetSetting(saIconContour, 0, i),
     SetSetting(sa2DOutline, 0, i)
    )
   )
  )
 ),
 
 {--The 2D- and 3D- Eventhandler of other passing atoms (in addition to Product or Container) can be changed to compensate rotationas--}
 {if(}
  {--atoms first passing of a CTU ?--}
  {not(Ddb([DrawFlag], i)),} 
  {--change 2D and 3D Eventhandler. Adding variable "ddb([DrawRotationas],product)" to rotate the product around self--}
  {CTU_Change_Passing_Atom_Drawing(i)}
 {),}
 
 {--get translation for drawing purpose of product to compensate the translation (caused by change of rotationas)--}
 CTU_Change_Product_Translation_On_Entered(c, i),
 
 if(
  MoveInFlag,
  {--place without input movement--}
  do(
   {---location depends on size of product--}
   SetLoc(0, 0, zSize(c), i),
   {--immediately start transfer time--}
   CreateEvent(0, c, 2, 0, i)
  ),
  {--input movement is enabled--}
  do(
   {--calculate x/y/z location of product before starting the input movement.--}
   CTU_Set_Product_Location(c,i),
   
   {--set product speed for input movement--}
   SetSpeed(
    {--evaluate x_motion flag--}
    Cell(CurIC, 3, c, 1) * Speed,
    {--evaluate y_motion flag--}
    Cell(CurIC, 4, c, 1) * Speed,
    {--no elevation in z--}
    0,
    i
   ),
  
   {--stop product when input movement (xsize or ysize of CTU) has finished--}
   CreateEvent(TravelTime(Speed, CTU_Detect_Transport_Length(c)), c, 2, 0, i)
  )
 ),
 
 EntryTrigger
)
]);
Set(OnExited, [do(
 {--close all oc--}
 CloseAllOc(c),
 
 {--Store time when product has left the CTU--}
 ExitTime := Time,
   
 {--get rotationas of output atom in order to calculate variable for drawing the product with correct rotationas--}
 Ddb([DrawRotationas], i) := Ddb([DrawRotationas], i) + CTU_Change_Product_Z_Rotation(c, i),
  
 {--Check whether a turn (left or right) requires a change of xsize and ysize of product in order to keep conveyors working correct--}
 CTU_Change_Product_XY_Size(c, i),
 
 {--bowdlerised rotation of output atom--}
 Ddb([DrawRotationas], i) := CTU_Adjust_Product_Rotation_As(Ddb([DrawRotationas], i)),  

 {--get translation for drawing purpose of product to compensate the translation (caused by change of rotationas)--}
 CTU_Change_Product_Translation_On_Exited(i),

 {--input strategy--}
 createEvent(0, c, 1),

 ExitTrigger
)
]);
Set(OnCreation, [AutoConnect
]);
Set(OnReset, [do( 
 {--Store the time when output movement has finished (no use for first product)--}
 ExitTime:=1E20,

 {--Used in OnIcReady to check for next input atom--}
 c.CheckFlag := 0,

 {--Status empty--}
 Status(c) := 13,

 {--Close all ic--}
 CloseAllIC(c),

 {--Close all oc--}
 CloseAllOc(c),
 
 {--Bowdlerise rotation information (<= 360°)--}
 InitialRotation := mod(InitialRotation, 360),
 
 {--Bowdlerise rotation information (>= -45° and <= 45°)--}
 if(InitialRotation < 0,
  InitialRotation := 360 + InitialRotation
 ),
     
 {--Rotate atom--}
 RotationAs(c) := InitialRotation,
 
 {--Configure table based on nr of ic + oc--} 
 SetTable(NrIC(c) + NrOC(c), 4, c),
 
 {--Column headers--}
 cell(0, 0, c) := [channel],
 cell(0, 1, c) := [atomname],
 cell(0, 2, c) := [rotationas],
 cell(0, 3, c) := [x_motionflag],
 cell(0, 4, c) := [y_motionflag],
 

 {--Get angles and motion directions of connected input atom--}
 Repeat(NrIC(c),
  CTU_Input_Atom_Set_Table(In(Count, c), c, Count)
 ),
 
 {--Get angles and motion directions of connected output atom--}
 Repeat(NrOC(c),
  CTU_Output_Atom_Set_Table(Out(Count, c), c, NrIC(c) + Count)
 ),
 
 {--Input strategy--}
 CreateEvent(0, c, 1),
 
 ResetTrigger
)
]);
Set(OnUser, [Do(
 { Delete any current instances of this form.} 
 GuiDestroy([Corner Transfer Unit]),

 { Register the GUI-form for this atom.}
 GuiRegister(PDir([\Atoms\Corner Transfer Unit.gui]), 1),

 { Show the GUI-form.}
 GuiCreate([Corner Transfer Unit], [Corner Transfer Unit], 0, c, 0, 1)
)
]);
Set(OnOcReady, [If(
 {--fail safe--}
 Content(c) > 0,
 {--send on the product to stored oc--}
 MoveRequest(First(c), CurOc)
)
]);
Set(OnIcReady, [do(
 if(
  {--check ic for next input atom--}
  c.CheckFlag,
  
  do(
   {--block all ic--}
   CloseAllIC(c),
   
   {--store ic that caused the ICReady--}
   CurIC:= ic(c),   
   
   {--Check whether following product has to wait in order to prevent collissions.--}
   StraightFlag := CTU_Detect_Collision(c),
               
   if(
    {--collissions detected ?--}
    StraightFlag,
    
    {--Straight ahead. Check for speed based collisions--}
    Case(
     WhichIsTrue(
      Att([Speed],Out(CurOC, c)) = Speed,
      Att([Speed],Out(CurOC, c)) > Speed,
      Att([Speed],Out(CurOC, c)) < Speed
     ),
     {--Output atom has same speed. Open input immediately--}
     createEvent(0, c, 7),
     {--Output atom ist faster. Open input immediately--}
     createEvent(0, c, 7),
     {--Output atom ist slower. Open input when exited product has left collision area--}
     createEvent(if(AtomExists(vtp(CTUAtom),Model),TravelTime(Att([Speed], Out(CurOC, c)), xSize(vtp(CTUAtom)))), c, 7)
    ),
 
    {--Turn. Wait till exited product has left collision area before open input again--}
    createEvent(if(AtomExists(vtp(CTUAtom),Model),TravelTime(Att([Speed], Out(CurOC, c)), xSize(vtp(CTUAtom)))), c, 7)
   )
  )
  
  {--else the already checked ic is stored in Attribut CurIC--}
  {--entering of product coming from CurIC triggers OnEntered--}
 )
)
]);
Set(On2DDraw, [do(
 {--Arrows of transport directions--}
 CTU_2Ddraw_direction_arrows(c)
)
]);
Set(On3DDraw, [Case(
 Icon3D,
 
 {--Non--}
 do(
  Icon3D := Icon3D
 ),

  {--Simple box--}
 do(
  di3DBox(0, 0, 0, xSize, ySize, zSize, Color)
 ),

 {--Box with icon--}
 do(
  di3DBox(0, 0, 0, xSize, ySize, zSize, Color,0, 0, Icon)
 ),
  
 {--CTU without icon--}
 do(
  CTU_3Ddraw_ctu_without_icon(c)
 ),
 
 {--CTU with icon--}
 do(
  CTU_3Ddraw_ctu_with_icon(c)
 ),
 
 {--CTU with chain conveyors--}
 do(
  CTU_3Ddraw_ctu_chain_conveyor(c)
 ),
 
 {--CTU with animated chain conveyors--}
 do(
  CTU_3Ddraw_ctu_chain_conveyor_animated(c)
 )
)
]);
SetStatus(0);
int018;
int007;
